<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Braybaut</title>
        <link>/posts/</link>
        <description>Recent content in Posts on Braybaut</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Thu, 06 Aug 2020 12:51:50 -0500</lastBuildDate>
        <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Integrate Terraform Language Server Protocol With vim</title>
            <link>/posts/integrate-terraform-language-server-protocol-with-vim/</link>
            <pubDate>Thu, 06 Aug 2020 12:51:50 -0500</pubDate>
            
            <guid>/posts/integrate-terraform-language-server-protocol-with-vim/</guid>
            <description>We write large-scale infrastructure with terraform. We spend hours creating modules, writing resources, developing infrastructure. To feel more comfortable, surely we need a langserver in our editor. I&amp;rsquo;ll show how to integrate a terraform langserver in vim - making it a Swiss Army Knife.
The Language Server protocol is used between a tool (the client) and a language smartness provider (the server) to integrate features. Like auto complete, go to definition, find all references and alike into the tool.</description>
            <content type="html"><![CDATA[<p><img src="/images/vim.png" alt=""></p>
<p>We write large-scale infrastructure with terraform. We spend hours creating modules, writing resources, developing infrastructure. To feel more comfortable, surely we need a langserver in our editor. I&rsquo;ll show how to integrate a terraform langserver in vim - making it a Swiss Army Knife.</p>
<p>The Language Server protocol is used between a tool (the client) and a language smartness provider (the server) to integrate features. Like auto complete, go to definition, find all references and alike into the tool. This post explains how to integrate <strong>terraform-lsp</strong> on vim.</p>
<h3 id="requirements">Requirements</h3>
<ul>
<li>Go &gt;= 1.14</li>
<li>nodejs &gt;= 10.12</li>
<li>vim &gt;= 8.0</li>
</ul>
<h3 id="install-coc-nvim-with-vim-plug">Install coc-nvim With vim-plug</h3>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">
<span style="color:#ed9d13">&#34; Use release branch (recommend)
</span><span style="color:#ed9d13">Plug &#39;neoclide/coc.nvim&#39;, {&#39;branch&#39;: &#39;release&#39;}
</span><span style="color:#ed9d13">
</span><span style="color:#ed9d13">&#34;</span> Or build from <span style="color:#24909d">source</span> code by using yarn: https://yarnpkg.com
Plug <span style="color:#ed9d13">&#39;neoclide/coc.nvim&#39;</span>, {<span style="color:#ed9d13">&#39;do&#39;</span>: <span style="color:#ed9d13">&#39;yarn install --frozen-lockfile&#39;</span>}

</code></pre></div><p>In .vimrc or init.vim, then restart Vim and run :PlugInstall.</p>
<h3 id="download-terraform-lsp">Download terraform-lsp</h3>
<p>Download a <a href="https://github.com/juliosueiras/terraform-lsp/releases">RELEASE</a> from github, extract file and move binary to /usr/local/sbin/</p>
<p>In this example I use Release <code>v0.0.11-beta2</code></p>
<p>Download file with wget</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">wget https://github.com/juliosueiras/terraform-lsp/releases/download/v0.0.11-beta2/terraform-lsp_0.0.11-beta2_linux_amd64.tar.gz
</code></pre></div><p>Extract file with tar</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">tar -xvf terraform-lsp_0.0.11-beta2_linux_amd64.tar.gz
</code></pre></div><p>Move file <strong>terraform-lsp</strong> to <code>/usr/local/bin/</code></p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo mv terraform-lsp /usr/local/bin/
</code></pre></div><h3 id="create-coc-nvim-config">Create coc-nvim Config</h3>
<p>Add snippet to <code>coc-setting.json</code> find file on ~/.vim/coc-setting.json or open file with <code>:CocConfig</code></p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
	<span style="color:#6ab825;font-weight:bold">&#34;languageserver&#34;</span>: {
		<span style="color:#6ab825;font-weight:bold">&#34;terraform&#34;</span>: {
			<span style="color:#6ab825;font-weight:bold">&#34;command&#34;</span>: <span style="color:#ed9d13">&#34;terraform-lsp&#34;</span>,
			<span style="color:#6ab825;font-weight:bold">&#34;filetypes&#34;</span>: [
				<span style="color:#ed9d13">&#34;terraform&#34;</span>,
				<span style="color:#ed9d13">&#34;tf&#34;</span>
			],
			<span style="color:#6ab825;font-weight:bold">&#34;initializationOptions&#34;</span>: {},
			<span style="color:#6ab825;font-weight:bold">&#34;settings&#34;</span>: {}
		}
	}
}
</code></pre></div><p>Now create new terraform files and resources to check autocomplete, attributes and more.</p>
<h3 id="usage">Usage:</h3>
<p>List resources available:</p>
<p><img src="/images/list-resources.png" alt=""></p>
<p>List attributes available:</p>
<p><img src="/images/attributes.png" alt=""></p>
<p>When attribute is required:</p>
<p><img src="/images/Errors.png" alt=""></p>
<h3 id="notes">Notes:</h3>
<ul>
<li>
<p>Currently there are two terraform lsp, <a href="https://github.com/juliosueiras/terraform-lsp">Terraform-lsp</a> and <a href="https://github.com/hashicorp/terraform-ls">Terraform-ls</a>.</p>
</li>
<li>
<p>Aim is a unified lsp for terraform, but for now there&rsquo;s two concurrent developments, terraform-lsp for experimental features and terraform-ls for stability</p>
</li>
</ul>
<h3 id="references">References:</h3>
<p><a href="https://github.com/juliosueiras/terraform-lsp">Terraform-lsp</a><br>
<a href="https://www.terraform.io/">Terraform</a><br>
<a href="https://langserver.org/">langserver.org</a><br>
<a href="https://github.com/neoclide/coc.nvim">coc-nvim</a></p>
]]></content>
        </item>
        
        <item>
            <title>Continuous Integration for Golang Applications with Terraform, Codebuilds and ECR</title>
            <link>/posts/continuous-integration-for-golang-applications-with-terraform-codebuilds-and-ecr/</link>
            <pubDate>Fri, 26 Jul 2019 16:58:24 -0500</pubDate>
            
            <guid>/posts/continuous-integration-for-golang-applications-with-terraform-codebuilds-and-ecr/</guid>
            <description>I wrote this post for sharing, how we can do continuous integration for Golang APIs with some tools. In this post I&amp;rsquo;m going to use terraform for making a codebuild resource, Code build to build the Golang API and generate a docker image and ECR for keeping the docker image.
The workflow: The continuous integration workflow is very easy to understand, every time a new tag is created the webhook will start the job, Codebuild will compile the Golang API and will generate the docker image, then will run a docker push to AWS ECR,</description>
            <content type="html"><![CDATA[<p><img src="/images/Gopher-aws.png" alt=""></p>
<p>I wrote this post for sharing, how we can do continuous integration for Golang APIs with some tools. In this post I&rsquo;m going to use terraform for making a codebuild resource, Code build to build the Golang API and generate a docker image and  ECR for keeping the docker image.</p>
<h3 id="the-workflow"><strong>The workflow:</strong></h3>
<p><img src="/images/workflow.png" alt=""></p>
<p>The continuous integration workflow is very easy to understand, every time a new tag is created the webhook will start the job, Codebuild will compile the Golang API and will generate the docker image, then will run a docker push to AWS ECR,</p>
<p>For this exercise, I pushed the code at  <a href="https://github.com/braybaut/Golang-API">https://github.com/braybaut/Golang-API</a>
This repository has the Golang API, Terraform files to deploy the AWS resources and buildspec to generate the steps</p>
<p>This code can be consulted at Github: <a href="https://github.com/braybaut/Golang-API">https://github.com/braybaut/Golang-API</a></p>
<pre><code>├── books.go
├── config
│   ├── aws.tf
│   ├── buildspec.yml
│   ├── codebuild.tf
│   ├── terraform.tfvars
│   └── variables.tf
├── Dockerfile
├── handlers.go
├── main.go
├── models.go
├── README.md
├── router.go
└── routes.go
</code></pre>
<p>The Golang Application is a minimal API that just show a little information of some books information that I&rsquo;ve read:</p>
<p>Routes:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">
<span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">init</span>() {
	routes = Routes{
		Route{
			<span style="color:#ed9d13">&#34;Index&#34;</span>,
			<span style="color:#ed9d13">&#34;GET&#34;</span>,
			<span style="color:#ed9d13">&#34;/&#34;</span>,
			<span style="color:#ed9d13">&#34;Index&#34;</span>,
			Index,
		},
		Route{
			<span style="color:#ed9d13">&#34;TodoShow&#34;</span>,
			<span style="color:#ed9d13">&#34;GET&#34;</span>,
			<span style="color:#ed9d13">&#34;/books/{bookId}&#34;</span>,
			<span style="color:#ed9d13">&#34;Get specific book with ID&#34;</span>,
			GetBook,
		},
		Route{
			<span style="color:#ed9d13">&#34;TodoIndex&#34;</span>,
			<span style="color:#ed9d13">&#34;GET&#34;</span>,
			<span style="color:#ed9d13">&#34;/books&#34;</span>,
			<span style="color:#ed9d13">&#34;Get all Books&#34;</span>,
			GetBooks,
		},

		Route{
			<span style="color:#ed9d13">&#34;info&#34;</span>,
			<span style="color:#ed9d13">&#34;GET&#34;</span>,
			<span style="color:#ed9d13">&#34;/info&#34;</span>,
			<span style="color:#ed9d13">&#34;Get Paths info&#34;</span>,
			GetPaths,
		},
	}
}


</code></pre></div><p>I won&rsquo;t talk much about the Golang code if you want to know more about the code, you can see the code at GitHub (I can write a post about golang in the future).</p>
<p>In orchestration Environment where many microservices run (for example golang) we need to pack our microservices, yes&hellip; the Golang binary can be our artifact but in this scenario, the real artifact is the Docker images that keep the Golang binary. For this case codebuild must compile the source code and generate the docker image, I wrote this buildspec.yml that run a docker build and docker do magic!!</p>
<p><strong>Dockerfile:</strong></p>
<pre><code class="language-console" data-lang="console">
FROM golang:alpine AS  builder 

RUN apk update &amp;&amp; apk add --no-cache git

RUN mkdir /app
ADD . /app
WORKDIR /app
RUN go get -d -v  
RUN go build -o library

FROM golang:alpine

COPY --from=builder /app/library /

EXPOSE 8080

ENTRYPOINT [&quot;/library&quot;]

</code></pre><p>The Dockerfile generates the Golang binary (library) y run this like entry point, also use the feature (multistage build) where we can make more optimized images (less size, fewer layers, etc)</p>
<p>Codebuild will handle  the process of generating the docker image, for this, we can define the instruction (phases)  with a yml file ( <strong>buildspec.yml</strong>)</p>
<p>The buildspec.yml must run these steps:</p>
<ul>
<li>login to ECR</li>
<li>Docker build  and tag the docker image</li>
<li>Docker push to ECR</li>
</ul>
<p><strong>buildspec.yml</strong></p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#6ab825;font-weight:bold">version</span>:<span style="color:#666"> </span><span style="color:#3677a9">0.2</span><span style="color:#666">
</span><span style="color:#666">
</span><span style="color:#666"></span><span style="color:#6ab825;font-weight:bold">git-credential-helper</span>:<span style="color:#666"> </span>yes<span style="color:#666">
</span><span style="color:#666">
</span><span style="color:#666"></span><span style="color:#6ab825;font-weight:bold">phases</span>:<span style="color:#666">
</span><span style="color:#666">    </span><span style="color:#6ab825;font-weight:bold">install</span>:<span style="color:#666">
</span><span style="color:#666">        </span><span style="color:#6ab825;font-weight:bold">runtime-versions</span>:<span style="color:#666">
</span><span style="color:#666">            </span><span style="color:#6ab825;font-weight:bold">docker</span>:<span style="color:#666"> </span><span style="color:#3677a9">18</span><span style="color:#666">
</span><span style="color:#666">    </span><span style="color:#6ab825;font-weight:bold">pre_build</span>:<span style="color:#666">
</span><span style="color:#666">        </span><span style="color:#6ab825;font-weight:bold">commands</span>:<span style="color:#666">
</span><span style="color:#666">            </span>- echo<span style="color:#666"> </span><span style="color:#ed9d13">&#34;loggin to AWS ECR&#34;</span><span style="color:#666">
</span><span style="color:#666">            </span>- $(aws<span style="color:#666"> </span>ecr<span style="color:#666"> </span>get-login<span style="color:#666"> </span>--no-include-email<span style="color:#666"> </span>--region<span style="color:#666"> </span>$AWS_DEFAULT_REGION)<span style="color:#666">
</span><span style="color:#666">
</span><span style="color:#666">    </span><span style="color:#6ab825;font-weight:bold">build</span>:<span style="color:#666">
</span><span style="color:#666">        </span><span style="color:#6ab825;font-weight:bold">commands</span>:<span style="color:#666">
</span><span style="color:#666">            </span>- echo<span style="color:#666"> </span><span style="color:#ed9d13">&#34;Getting Tag..&#34;</span><span style="color:#666">
</span><span style="color:#666">            </span>- <span style="color:#ed9d13">|
</span><span style="color:#ed9d13">              if [ -z $CODEBUILD_WEBHOOK_TRIGGER ]; then  </span><span style="color:#666">
</span><span style="color:#666">                </span>export<span style="color:#666"> </span>IMAGE_TAG=$CODEBUILD_SOURCE_VERSION<span style="color:#666">
</span><span style="color:#666">              </span>else<span style="color:#666"> 
</span><span style="color:#666">                </span>export<span style="color:#666"> </span>IMAGE_TAG=$(echo<span style="color:#666"> </span>$CODEBUILD_WEBHOOK_TRIGGER<span style="color:#666"> </span>|<span style="color:#666"> </span>cut<span style="color:#666"> </span>-d<span style="color:#666"> </span><span style="color:#ed9d13">&#34;/&#34;</span><span style="color:#666"> </span>-f2)<span style="color:#666">
</span><span style="color:#666">                </span>fi<span style="color:#666"> 
</span><span style="color:#666">            </span>- echo<span style="color:#666"> </span><span style="color:#ed9d13">&#34;verify tag..&#34;</span><span style="color:#666">
</span><span style="color:#666">            </span>- echo<span style="color:#666"> </span>$IMAGE_TAG<span style="color:#666"> 
</span><span style="color:#666">            </span>- echo<span style="color:#666"> </span><span style="color:#ed9d13">&#34;Building the docker image..&#34;</span><span style="color:#666">
</span><span style="color:#666">            </span>- docker<span style="color:#666"> </span>build<span style="color:#666"> </span>-t<span style="color:#666"> </span>$IMAGE_REPO_NAME:$IMAGE_TAG<span style="color:#666"> </span>.<span style="color:#666">
</span><span style="color:#666">            </span>- docker<span style="color:#666"> </span>tag<span style="color:#666"> </span>$IMAGE_REPO_NAME:$IMAGE_TAG<span style="color:#666"> </span>$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG<span style="color:#666"> 
</span><span style="color:#666">    </span><span style="color:#6ab825;font-weight:bold">post_build</span>:<span style="color:#666">
</span><span style="color:#666">        </span><span style="color:#6ab825;font-weight:bold">commands</span>:<span style="color:#666">
</span><span style="color:#666">            </span>- echo<span style="color:#666"> </span><span style="color:#ed9d13">&#34;Pushing Docker image&#34;</span><span style="color:#666">
</span><span style="color:#666">            </span>- docker<span style="color:#666"> </span>push<span style="color:#666"> </span>$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG<span style="color:#666"> 
</span></code></pre></div><h3 id="how-determinate-the-tag"><strong>How determinate the tag?</strong></h3>
<p>Our pipeline can start manually or automatically, if start manually we can set the repository tag to build, this tag is keeping an environment variable <strong>CODEBUILD_SOURCE_VERSION,</strong> but if start automatically the value is keeping in <strong>CODEBUILD_WEBHOOK_TRIGGER</strong> to know this, the build stage has a conditional to get the correct tag</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">
<span style="color:#6ab825;font-weight:bold">if</span> [ -z <span style="color:#40ffff">$CODEBUILD_WEBHOOK_TRIGGER</span> ]; <span style="color:#6ab825;font-weight:bold">then</span>  
   <span style="color:#24909d">export</span> <span style="color:#40ffff">IMAGE_TAG</span>=<span style="color:#40ffff">$CODEBUILD_SOURCE_VERSION</span>
<span style="color:#6ab825;font-weight:bold">else</span> 
   <span style="color:#24909d">export</span> <span style="color:#40ffff">IMAGE_TAG</span>=<span style="color:#6ab825;font-weight:bold">$(</span><span style="color:#24909d">echo</span> <span style="color:#40ffff">$CODEBUILD_WEBHOOK_TRIGGER</span> | cut -d <span style="color:#ed9d13">&#34;/&#34;</span> -f2<span style="color:#6ab825;font-weight:bold">)</span>
<span style="color:#6ab825;font-weight:bold">fi</span> 
</code></pre></div><p>We have the golang code and  dockerfile to build the docker image and buildspec.yml, now we need the terraform file to deploy codebuild and ECR.</p>
<h3 id="deploying-codebuild"><strong>Deploying Codebuild:</strong></h3>
<p>For this point, we have some terraform files, for example:</p>
<p><strong>terraform.tfvars:</strong>  Set the needed variables for example AWS_ACCOUNT_ID</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#40ffff">AWS_ACCOUNT_ID</span>=
<span style="color:#40ffff">AWS_REGION</span>=<span style="color:#ed9d13">&#34;us-east-1&#34;</span>
<span style="color:#40ffff">IMAGE_REPO_NAME</span>=<span style="color:#ed9d13">&#34;library-api&#34;</span>
<span style="color:#40ffff">URL_REPO</span>=<span style="color:#ed9d13">&#34;https://github.com/braybaut/Golang-API.git&#34;</span>
</code></pre></div><p><strong>variables.tf:</strong>  make the variables with terraform.tfvars values</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">
variable <span style="color:#ed9d13">&#34;URL_REPO&#34;</span> {
  <span style="color:#24909d">type</span> = string

}

variable <span style="color:#ed9d13">&#34;AWS_REGION&#34;</span> {
  <span style="color:#24909d">type</span> = string
}

variable <span style="color:#ed9d13">&#34;IMAGE_REPO_NAME&#34;</span> {
  <span style="color:#24909d">type</span> = string
}

variable <span style="color:#ed9d13">&#34;AWS_ACCOUNT_ID&#34;</span> {
  <span style="color:#24909d">type</span> = string
}
</code></pre></div><p><strong>aws.tf:</strong> Set the provider to use</p>
<pre><code class="language-console" data-lang="console">provider &quot;aws&quot; {
  region = &quot;${var.AWS_REGION}&quot;
}
</code></pre><p><strong>codebuild.tf:</strong> policies, roles, codebuild, ECR to create</p>
<p>This file has S3, ECR, policies, role, and other definitions that are needed to this workflow, but I just paste the codebuild resources, this definition only set some environment variables needed to Buildspec, set the log-stream configuration and define the source</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">resource <span style="color:#ed9d13">&#34;aws_codebuild_project&#34;</span> <span style="color:#ed9d13">&#34;library-build&#34;</span> {
  <span style="color:#40ffff">name</span> = <span style="color:#ed9d13">&#34;library-build&#34;</span>
  <span style="color:#40ffff">description</span> = <span style="color:#ed9d13">&#34;Easy build to generate docker image for Golang Applications&#34;</span>
  <span style="color:#40ffff">build_timeout</span> = <span style="color:#ed9d13">&#34;5&#34;</span>
  <span style="color:#40ffff">service_role</span> = <span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">${</span><span style="color:#40ffff">aws_iam_role</span>.code-build-library.arn<span style="color:#ed9d13">}</span><span style="color:#ed9d13">&#34;</span>

  artifacts {
    <span style="color:#24909d">type</span> = <span style="color:#ed9d13">&#34;NO_ARTIFACTS&#34;</span>
  }

  cache {
    <span style="color:#24909d">type</span> = <span style="color:#ed9d13">&#34;S3&#34;</span>
    <span style="color:#40ffff">location</span> = <span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">${</span><span style="color:#40ffff">aws_s3_bucket</span>.library-build.bucket<span style="color:#ed9d13">}</span><span style="color:#ed9d13">&#34;</span>
  }

  environment {
    <span style="color:#40ffff">compute_type</span> = <span style="color:#ed9d13">&#34;BUILD_GENERAL1_SMALL&#34;</span>
    <span style="color:#40ffff">image</span> = <span style="color:#ed9d13">&#34;aws/codebuild/standard:2.0&#34;</span>
    <span style="color:#24909d">type</span> = <span style="color:#ed9d13">&#34;LINUX_CONTAINER&#34;</span>
    <span style="color:#40ffff">image_pull_credentials_type</span> = <span style="color:#ed9d13">&#34;CODEBUILD&#34;</span>
<span style="color:#40ffff">privileged_mode</span> = <span style="color:#24909d">true</span>

   environment_variable {
      <span style="color:#40ffff">name</span> = <span style="color:#ed9d13">&#34;AWS_DEFAULT_REGION&#34;</span>
      <span style="color:#40ffff">value</span> = <span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">${</span><span style="color:#40ffff">var</span>.AWS_REGION<span style="color:#ed9d13">}</span><span style="color:#ed9d13">&#34;</span>
    }
   environment_variable {
      <span style="color:#40ffff">name</span> = <span style="color:#ed9d13">&#34;AWS_ACCOUNT_ID&#34;</span>
      <span style="color:#40ffff">value</span> = <span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">${</span><span style="color:#40ffff">var</span>.AWS_ACCOUNT_ID<span style="color:#ed9d13">}</span><span style="color:#ed9d13">&#34;</span>
    }

    environment_variable {
      <span style="color:#40ffff">name</span> = <span style="color:#ed9d13">&#34;IMAGE_REPO_NAME&#34;</span>
      <span style="color:#40ffff">value</span> = <span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">${</span><span style="color:#40ffff">var</span>.IMAGE_REPO_NAME<span style="color:#ed9d13">}</span><span style="color:#ed9d13">&#34;</span>
    }

  }

  logs_config {
    cloudwatch_logs {
      <span style="color:#40ffff">group_name</span> = <span style="color:#ed9d13">&#34;log-group&#34;</span>
      <span style="color:#40ffff">stream_name</span> = <span style="color:#ed9d13">&#34;log-stream&#34;</span>
    }

    s3_logs {
      <span style="color:#40ffff">status</span> = <span style="color:#ed9d13">&#34;ENABLED&#34;</span>
      <span style="color:#40ffff">location</span> = <span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">${</span><span style="color:#40ffff">aws_s3_bucket</span>.library-build.id<span style="color:#ed9d13">}</span><span style="color:#ed9d13">/build-log&#34;</span>
    }
  }

  <span style="color:#24909d">source</span> {
    <span style="color:#24909d">type</span> = <span style="color:#ed9d13">&#34;GITHUB&#34;</span>
    <span style="color:#40ffff">location</span> = <span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">${</span><span style="color:#40ffff">var</span>.URL_REPO<span style="color:#ed9d13">}</span><span style="color:#ed9d13">&#34;</span>
    <span style="color:#40ffff">git_clone_depth</span> = <span style="color:#3677a9">1</span>
    <span style="color:#40ffff">buildspec</span> = <span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">${</span><span style="color:#40ffff">file</span>(<span style="color:#ed9d13">&#34;buildspec.yml&#34;</span>)<span style="color:#ed9d13">}</span><span style="color:#ed9d13">&#34;</span>
  }
 
}
</code></pre></div><h3 id="enabling-webhook"><strong>Enabling webhook:</strong></h3>
<p>This definition will create a webhook to start the job, this webhook has filters that exclude everything that meets the &ldquo;^refs/heads/.<em>&rdquo; pattern ( new commits, new branches, etc ) and the hook will trigger when the pattern &ldquo;^refs/tags/.</em>&rdquo; is met ( create new tags )</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">resource <span style="color:#ed9d13">&#34;aws_codebuild_webhook&#34;</span> <span style="color:#ed9d13">&#34;library-webhook&#34;</span> {
  <span style="color:#40ffff">project_name</span> = <span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">${</span><span style="color:#40ffff">aws_codebuild_project</span>.library-build.name<span style="color:#ed9d13">}</span><span style="color:#ed9d13">&#34;</span>

  filter_group {
    filter {
      <span style="color:#24909d">type</span> = <span style="color:#ed9d13">&#34;EVENT&#34;</span>
      <span style="color:#40ffff">pattern</span> = <span style="color:#ed9d13">&#34;PUSH&#34;</span>
    }

   filter {
      <span style="color:#24909d">type</span> = <span style="color:#ed9d13">&#34;HEAD_REF&#34;</span>
      <span style="color:#40ffff">pattern</span> = <span style="color:#ed9d13">&#34;^refs/tags/.*&#34;</span>
    }
   filter {
      <span style="color:#24909d">type</span> = <span style="color:#ed9d13">&#34;HEAD_REF&#34;</span>
      <span style="color:#40ffff">pattern</span> = <span style="color:#ed9d13">&#34;^refs/heads/.*&#34;</span>
      <span style="color:#40ffff">exclude_matched_pattern</span> = <span style="color:#ed9d13">&#34;true&#34;</span>
    }


  }
}
</code></pre></div><p>Now that we have all files to make the pipeline, we need to deploy all resources, to Deploy terraform files is needed set the AWS keys as environment variables, then run <strong>terraform init and terraform apply commands:</strong></p>
<p>Terraform will create 7 resources, if the creation process was good, we can see these resources created:</p>
<pre><code>    aws_codebuild_project.library-build
    aws_codebuild_webhook.library-webhook
    aws_ecr_repository.library-ecr
    aws_iam_role.code-build-library
    aws_iam_role_policy.ecr-policy
    aws_iam_role_policy.s3-policy
    aws_s3_bucket.library-build
</code></pre><p>we can see the new Codebuild project  and the ECR created</p>
<p><strong>Codebuild project:</strong></p>
<p><img src="/images/codebuild.png" alt=""></p>
<p><strong>ECR</strong></p>
<p><img src="/images/ecr.png" alt=""></p>
<p>The resources is created, we can test the webhook create a new tag from github:</p>
<p>we create a new release:</p>
<p><img src="/images/release.png" alt=""></p>
<p>Verify that the build is running:</p>
<p><img src="/images/library-build.png" alt=""></p>
<p>The build was started, also we can see the logs</p>
<p><img src="/images/library-build-result.png" alt=""></p>
<p>When the job finished, we can see the new docker image at ECR</p>
<p><img src="/images/ecr-library.png" alt=""></p>
<p>Our Continuous integration workflow finish there, we can see that the docker image tag is the same to the tag set as release at github:</p>
<p><img src="/images/testing-webhook.png" alt=""></p>
<p>This was a little example that how we can create an  easy continuous integration for Golang APIs with Codebuild, GitHub and Terraform, In the next post I will write how can create a continuous delivery workflow with CodeDeploy and Fargate and other post joining both workflows to make a pipeline with continuous integration and delivery workflow.</p>
]]></content>
        </item>
        
        <item>
            <title>Construyendo Un cluster de Kubernetes en AWS EKS Con Terraform</title>
            <link>/posts/construyendo-un-cluster-de-kubernetes-en-aws-eks-con-terraform/</link>
            <pubDate>Fri, 05 Apr 2019 09:03:17 -0500</pubDate>
            
            <guid>/posts/construyendo-un-cluster-de-kubernetes-en-aws-eks-con-terraform/</guid>
            <description>Kubernetes sin duda es uno de los mejores containers orquestation que tenemos en el mercado y hoy en dia, muchos vendors ofrecen Kubernetes como servicio, AWS no se ha quedado atras y en junio del año pasado, anuncio Elastic Kubernetes Services.
El cluster que desplegaremos, se compone de los siguientes resources:</description>
            <content type="html"><![CDATA[<p><img src="/images/Terra-EKS.png" alt=""></p>
<p>Kubernetes sin duda es uno de los mejores containers orquestation que tenemos en el mercado y hoy en dia, muchos vendors ofrecen Kubernetes como servicio, AWS no se ha quedado atras y en junio del año pasado, anuncio Elastic Kubernetes Services.</p>
<p>El cluster que desplegaremos, se compone de los siguientes resources:</p>
]]></content>
        </item>
        
        <item>
            <title>Parseando JSON con Golang y las naves de spaceX</title>
            <link>/posts/parseando-json-con-golang-y-las-naves-de-spacex/</link>
            <pubDate>Sun, 10 Feb 2019 21:52:53 +0000</pubDate>
            
            <guid>/posts/parseando-json-con-golang-y-las-naves-de-spacex/</guid>
            <description>&lt;p&gt;&lt;img src=&#34;/images/maxresdefault.jpg&#34; alt=&#34;Golang&#34;&gt;&lt;/p&gt;
&lt;p&gt;Golang se ha convertido en uno de mis lenguajes favoritos y hoy escribiré de como podemos usar go para poder consumir la API de spaceX y obtener información de las naves lanzadas al espacio&lt;/p&gt;
&lt;p&gt;Soy admirador total de &lt;a href=&#34;https://en.wikipedia.org/wiki/Elon_Musk&#34;&gt;Elon musk&lt;/a&gt; y de todas sus compañías, una de ellas es &lt;a href=&#34;https://www.spacex.com/&#34;&gt;spaceX&lt;/a&gt;, una compañía dedicada al transporte aeroespacial y hoy por medio de Golang vamos a obtener información de su ultima nave lanzada al espacio.&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p><img src="/images/maxresdefault.jpg" alt="Golang"></p>
<p>Golang se ha convertido en uno de mis lenguajes favoritos y hoy escribiré de como podemos usar go para poder consumir la API de spaceX y obtener información de las naves lanzadas al espacio</p>
<p>Soy admirador total de <a href="https://en.wikipedia.org/wiki/Elon_Musk">Elon musk</a> y de todas sus compañías, una de ellas es <a href="https://www.spacex.com/">spaceX</a>, una compañía dedicada al transporte aeroespacial y hoy por medio de Golang vamos a obtener información de su ultima nave lanzada al espacio.</p>
<p>SpaceX provee una API para obtener toda la información de las naves lanzadas al espacio:</p>
<pre><code class="language-console" data-lang="console">curl -x https://api.spacexdata.com/v3/launches/latest | jq .
</code></pre><p>Con esta API podemos obtener los siguientes datos:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#6ab825;font-weight:bold">&#34;flight_number&#34;</span>: <span style="color:#3677a9">74</span>,
  <span style="color:#6ab825;font-weight:bold">&#34;mission_name&#34;</span>: <span style="color:#ed9d13">&#34;Iridium NEXT Mission 8&#34;</span>,
  <span style="color:#6ab825;font-weight:bold">&#34;mission_id&#34;</span>: [
    <span style="color:#ed9d13">&#34;F3364BF&#34;</span>
  ],
  <span style="color:#6ab825;font-weight:bold">&#34;launch_year&#34;</span>: <span style="color:#ed9d13">&#34;2019&#34;</span>,
  <span style="color:#6ab825;font-weight:bold">&#34;launch_date_unix&#34;</span>: <span style="color:#3677a9">1547220660</span>,
  <span style="color:#6ab825;font-weight:bold">&#34;launch_date_utc&#34;</span>: <span style="color:#ed9d13">&#34;2019-01-11T15:31:00.000Z&#34;</span>,
  <span style="color:#6ab825;font-weight:bold">&#34;launch_date_local&#34;</span>: <span style="color:#ed9d13">&#34;2019-01-11T07:31:00-08:00&#34;</span>,
  <span style="color:#6ab825;font-weight:bold">&#34;is_tentative&#34;</span>: <span style="color:#6ab825;font-weight:bold">false</span>,
  <span style="color:#6ab825;font-weight:bold">&#34;tentative_max_precision&#34;</span>: <span style="color:#ed9d13">&#34;hour&#34;</span>,
  <span style="color:#6ab825;font-weight:bold">&#34;tbd&#34;</span>: <span style="color:#6ab825;font-weight:bold">false</span>,
  <span style="color:#6ab825;font-weight:bold">&#34;launch_window&#34;</span>: <span style="color:#3677a9">0</span>,
  <span style="color:#6ab825;font-weight:bold">&#34;rocket&#34;</span>: {
    <span style="color:#6ab825;font-weight:bold">&#34;rocket_id&#34;</span>: <span style="color:#ed9d13">&#34;falcon9&#34;</span>,
    <span style="color:#6ab825;font-weight:bold">&#34;rocket_name&#34;</span>: <span style="color:#ed9d13">&#34;Falcon 9&#34;</span>,
    <span style="color:#6ab825;font-weight:bold">&#34;rocket_type&#34;</span>: <span style="color:#ed9d13">&#34;FT&#34;</span>,
    <span style="color:#6ab825;font-weight:bold">&#34;first_stage&#34;</span>: {
      <span style="color:#6ab825;font-weight:bold">&#34;cores&#34;</span>: [
        {
          <span style="color:#6ab825;font-weight:bold">&#34;core_serial&#34;</span>: <span style="color:#ed9d13">&#34;B1049&#34;</span>,
          <span style="color:#6ab825;font-weight:bold">&#34;flight&#34;</span>: <span style="color:#3677a9">2</span>,
          <span style="color:#6ab825;font-weight:bold">&#34;block&#34;</span>: <span style="color:#3677a9">5</span>,
          <span style="color:#6ab825;font-weight:bold">&#34;gridfins&#34;</span>: <span style="color:#6ab825;font-weight:bold">true</span>,
          <span style="color:#6ab825;font-weight:bold">&#34;legs&#34;</span>: <span style="color:#6ab825;font-weight:bold">true</span>,
          <span style="color:#6ab825;font-weight:bold">&#34;reused&#34;</span>: <span style="color:#6ab825;font-weight:bold">true</span>,
          <span style="color:#6ab825;font-weight:bold">&#34;land_success&#34;</span>: <span style="color:#6ab825;font-weight:bold">true</span>,
          <span style="color:#6ab825;font-weight:bold">&#34;landing_intent&#34;</span>: <span style="color:#6ab825;font-weight:bold">true</span>,
          <span style="color:#6ab825;font-weight:bold">&#34;landing_type&#34;</span>: <span style="color:#ed9d13">&#34;ASDS&#34;</span>,
          <span style="color:#6ab825;font-weight:bold">&#34;landing_vehicle&#34;</span>: <span style="color:#ed9d13">&#34;JRTI&#34;</span>
        }
      ]
    },
    <span style="color:#6ab825;font-weight:bold">&#34;second_stage&#34;</span>: {
      <span style="color:#6ab825;font-weight:bold">&#34;block&#34;</span>: <span style="color:#3677a9">5</span>,
      <span style="color:#6ab825;font-weight:bold">&#34;payloads&#34;</span>: [
        {
          <span style="color:#6ab825;font-weight:bold">&#34;payload_id&#34;</span>: <span style="color:#ed9d13">&#34;Iridium NEXT 8&#34;</span>,
          <span style="color:#6ab825;font-weight:bold">&#34;norad_id&#34;</span>: [
            <span style="color:#3677a9">43922</span>,
            <span style="color:#3677a9">43923</span>,
            <span style="color:#3677a9">43924</span>,
            <span style="color:#3677a9">43925</span>,
            <span style="color:#3677a9">43926</span>,
            <span style="color:#3677a9">43927</span>,
            <span style="color:#3677a9">43928</span>,
            <span style="color:#3677a9">43929</span>,
            <span style="color:#3677a9">43930</span>,
            <span style="color:#3677a9">43931</span>
          ],
          <span style="color:#6ab825;font-weight:bold">&#34;reused&#34;</span>: <span style="color:#6ab825;font-weight:bold">false</span>,
          <span style="color:#6ab825;font-weight:bold">&#34;customers&#34;</span>: [
            <span style="color:#ed9d13">&#34;Iridium Communications&#34;</span>
          ],
          <span style="color:#6ab825;font-weight:bold">&#34;nationality&#34;</span>: <span style="color:#ed9d13">&#34;United States&#34;</span>,
          <span style="color:#6ab825;font-weight:bold">&#34;manufacturer&#34;</span>: <span style="color:#ed9d13">&#34;Thales Alenia Space&#34;</span>,
          <span style="color:#6ab825;font-weight:bold">&#34;payload_type&#34;</span>: <span style="color:#ed9d13">&#34;Satellite&#34;</span>,
          <span style="color:#6ab825;font-weight:bold">&#34;payload_mass_kg&#34;</span>: <span style="color:#3677a9">9600</span>,
          <span style="color:#6ab825;font-weight:bold">&#34;payload_mass_lbs&#34;</span>: <span style="color:#3677a9">21164.38</span>,
          <span style="color:#6ab825;font-weight:bold">&#34;orbit&#34;</span>: <span style="color:#ed9d13">&#34;PO&#34;</span>,
          <span style="color:#6ab825;font-weight:bold">&#34;orbit_params&#34;</span>: {
            <span style="color:#6ab825;font-weight:bold">&#34;reference_system&#34;</span>: <span style="color:#ed9d13">&#34;geocentric&#34;</span>,
            <span style="color:#6ab825;font-weight:bold">&#34;regime&#34;</span>: <span style="color:#ed9d13">&#34;low-earth&#34;</span>,
            <span style="color:#6ab825;font-weight:bold">&#34;longitude&#34;</span>: <span style="color:#6ab825;font-weight:bold">null</span>,
            <span style="color:#6ab825;font-weight:bold">&#34;semi_major_axis_km&#34;</span>: <span style="color:#3677a9">6997.303</span>,
            <span style="color:#6ab825;font-weight:bold">&#34;eccentricity&#34;</span>: <span style="color:#3677a9">0.0011185</span>,
            <span style="color:#6ab825;font-weight:bold">&#34;periapsis_km&#34;</span>: <span style="color:#3677a9">611.342</span>,
            <span style="color:#6ab825;font-weight:bold">&#34;apoapsis_km&#34;</span>: <span style="color:#3677a9">626.995</span>,
            <span style="color:#6ab825;font-weight:bold">&#34;inclination_deg&#34;</span>: <span style="color:#3677a9">86.6809</span>,
            <span style="color:#6ab825;font-weight:bold">&#34;period_min&#34;</span>: <span style="color:#3677a9">97.085</span>,
            <span style="color:#6ab825;font-weight:bold">&#34;lifespan_years&#34;</span>: <span style="color:#3677a9">15</span>,
            <span style="color:#6ab825;font-weight:bold">&#34;epoch&#34;</span>: <span style="color:#ed9d13">&#34;2019-01-14T19:01:22.000Z&#34;</span>,
            <span style="color:#6ab825;font-weight:bold">&#34;mean_motion&#34;</span>: <span style="color:#3677a9">14.83223805</span>,
            <span style="color:#6ab825;font-weight:bold">&#34;raan&#34;</span>: <span style="color:#3677a9">46.2409</span>,
            <span style="color:#6ab825;font-weight:bold">&#34;arg_of_pericenter&#34;</span>: <span style="color:#3677a9">203.1527</span>,
            <span style="color:#6ab825;font-weight:bold">&#34;mean_anomaly&#34;</span>: <span style="color:#3677a9">156.9184</span>
          }
        }
      ]
    },
    <span style="color:#6ab825;font-weight:bold">&#34;fairings&#34;</span>: {
      <span style="color:#6ab825;font-weight:bold">&#34;reused&#34;</span>: <span style="color:#6ab825;font-weight:bold">false</span>,
      <span style="color:#6ab825;font-weight:bold">&#34;recovery_attempt&#34;</span>: <span style="color:#6ab825;font-weight:bold">false</span>,
      <span style="color:#6ab825;font-weight:bold">&#34;recovered&#34;</span>: <span style="color:#6ab825;font-weight:bold">null</span>,
      <span style="color:#6ab825;font-weight:bold">&#34;ship&#34;</span>: <span style="color:#6ab825;font-weight:bold">null</span>
    }
  },
  <span style="color:#6ab825;font-weight:bold">&#34;ships&#34;</span>: [
    <span style="color:#ed9d13">&#34;JRTI-2&#34;</span>,
    <span style="color:#ed9d13">&#34;NRCQUEST&#34;</span>,
    <span style="color:#ed9d13">&#34;PACIFICFREEDOM&#34;</span>
  ],
  <span style="color:#6ab825;font-weight:bold">&#34;telemetry&#34;</span>: {
    <span style="color:#6ab825;font-weight:bold">&#34;flight_club&#34;</span>: <span style="color:#ed9d13">&#34;https://www.flightclub.io/result?code=IRD8&#34;</span>
  },
  <span style="color:#6ab825;font-weight:bold">&#34;launch_site&#34;</span>: {
    <span style="color:#6ab825;font-weight:bold">&#34;site_id&#34;</span>: <span style="color:#ed9d13">&#34;vafb_slc_4e&#34;</span>,
    <span style="color:#6ab825;font-weight:bold">&#34;site_name&#34;</span>: <span style="color:#ed9d13">&#34;VAFB SLC 4E&#34;</span>,
    <span style="color:#6ab825;font-weight:bold">&#34;site_name_long&#34;</span>: <span style="color:#ed9d13">&#34;Vandenberg Air Force Base Space Launch Complex 4E&#34;</span>
  },
  <span style="color:#6ab825;font-weight:bold">&#34;launch_success&#34;</span>: <span style="color:#6ab825;font-weight:bold">true</span>,
  <span style="color:#6ab825;font-weight:bold">&#34;links&#34;</span>: {
    <span style="color:#6ab825;font-weight:bold">&#34;mission_patch&#34;</span>: <span style="color:#ed9d13">&#34;https://images2.imgbox.com/80/ae/1JL1ZzXD_o.png&#34;</span>,
    <span style="color:#6ab825;font-weight:bold">&#34;mission_patch_small&#34;</span>: <span style="color:#ed9d13">&#34;https://images2.imgbox.com/11/f0/xPDcIpmS_o.png&#34;</span>,
    <span style="color:#6ab825;font-weight:bold">&#34;reddit_campaign&#34;</span>: <span style="color:#ed9d13">&#34;https://www.reddit.com/r/spacex/comments/a699fh/iridium_next_constellation_mission_8_launch/&#34;</span>,
    <span style="color:#6ab825;font-weight:bold">&#34;reddit_launch&#34;</span>: <span style="color:#ed9d13">&#34;https://www.reddit.com/r/spacex/comments/aemq2i/rspacex_iridium_next_8_official_launch_discussion/&#34;</span>,
    <span style="color:#6ab825;font-weight:bold">&#34;reddit_recovery&#34;</span>: <span style="color:#ed9d13">&#34;https://www.reddit.com/r/spacex/comments/aewp4r/iridium_8_recovery_thread/&#34;</span>,
    <span style="color:#6ab825;font-weight:bold">&#34;reddit_media&#34;</span>: <span style="color:#ed9d13">&#34;https://www.reddit.com/r/spacex/comments/aeoxve/rspacex_iridium_next_8_media_thread_videos_images/&#34;</span>,
    <span style="color:#6ab825;font-weight:bold">&#34;presskit&#34;</span>: <span style="color:#ed9d13">&#34;https://www.spacex.com/sites/spacex/files/iridium8presskit.pdf&#34;</span>,
    <span style="color:#6ab825;font-weight:bold">&#34;article_link&#34;</span>: <span style="color:#ed9d13">&#34;https://spaceflightnow.com/2019/01/11/spacex-begins-2019-with-eighth-and-final-for-upgraded-iridium-network/&#34;</span>,
    <span style="color:#6ab825;font-weight:bold">&#34;wikipedia&#34;</span>: <span style="color:#ed9d13">&#34;https://en.wikipedia.org/wiki/Iridium_satellite_constellation#Next-generation_constellation&#34;</span>,
    <span style="color:#6ab825;font-weight:bold">&#34;video_link&#34;</span>: <span style="color:#ed9d13">&#34;https://youtu.be/VshdafZvwrg&#34;</span>,
    <span style="color:#6ab825;font-weight:bold">&#34;youtube_id&#34;</span>: <span style="color:#ed9d13">&#34;VshdafZvwrg&#34;</span>,
    <span style="color:#6ab825;font-weight:bold">&#34;flickr_images&#34;</span>: [
      <span style="color:#ed9d13">&#34;https://farm5.staticflickr.com/4866/39745612523_14270b4b9d_o.jpg&#34;</span>,
      <span style="color:#ed9d13">&#34;https://farm8.staticflickr.com/7833/39745612923_21aa442350_o.jpg&#34;</span>,
      <span style="color:#ed9d13">&#34;https://farm5.staticflickr.com/4881/39745613173_e99b09c000_o.jpg&#34;</span>,
      <span style="color:#ed9d13">&#34;https://farm8.staticflickr.com/7882/39745613513_6cdd4581af_o.jpg&#34;</span>,
      <span style="color:#ed9d13">&#34;https://farm8.staticflickr.com/7807/39745613733_1a7b70e54a_o.jpg&#34;</span>,
      <span style="color:#ed9d13">&#34;https://farm5.staticflickr.com/4891/39745614053_43855205bc_o.jpg&#34;</span>
    ]
  },
  <span style="color:#6ab825;font-weight:bold">&#34;details&#34;</span>: <span style="color:#ed9d13">&#34;SpaceX&#39;s first flight of 2019 will be the eighth and final launch of its planned Iridium flights. Delivering 10 satellites to low earth orbit, this brings the total up to 75 and completes the Iridium NEXT constellation. This mission launches from SLC-4E at Vandenberg AFB. The booster is expected to land on JRTI.&#34;</span>,
  <span style="color:#6ab825;font-weight:bold">&#34;upcoming&#34;</span>: <span style="color:#6ab825;font-weight:bold">false</span>,
  <span style="color:#6ab825;font-weight:bold">&#34;static_fire_date_utc&#34;</span>: <span style="color:#ed9d13">&#34;2019-01-06T13:51:00.000Z&#34;</span>,
  <span style="color:#6ab825;font-weight:bold">&#34;static_fire_date_unix&#34;</span>: <span style="color:#3677a9">1546782660</span>,
  <span style="color:#6ab825;font-weight:bold">&#34;timeline&#34;</span>: <span style="color:#6ab825;font-weight:bold">null</span>
}
</code></pre></div><p>Pero no queremos toda la información que nos da el API, solo queremos saber, estos tres valores: Number Flight, mission Name y description. para esto, usaremos Go y consumiremos la API.</p>
<h3 id="pre-requisitos"><strong>Pre-requisitos</strong></h3>
<ul>
<li>Instalar Go desde <a href="https://golang.org/dl/">https://golang.org/dl/</a></li>
<li>Chequear la instalación de Go con <strong>go version </strong>// Yo estoy utilizando la version 1.9.1</li>
<li>Para este caso utilizare librerías estándares de Go, ya que tiene los componentes de HTTP y JSON necesarios.</li>
<li>Pueden utilizar el editor de texto que quieran, yo utilizo vim con el plugin <a href="https://github.com/fatih/vim-go">go-vim</a></li>
</ul>
<!-- raw HTML omitted -->
<p>creamos un archivo llamado <strong>spaceX.go y</strong> escribimos las lineas básicas de nuestro archivo:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6ab825;font-weight:bold">package</span> main

<span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">main</span>() {

}
</code></pre></div><p>podemos ejecutar nuestro archivo como <strong>go run spaceX.go</strong> o <strong>go build ./spaceX.go</strong></p>
<p>Ahora crearemos el request hacia la API y parsearemos el output para tener los valores que necesitamos:, para eso necesitamos los siguientes librerías</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6ab825;font-weight:bold">import</span> (
<span style="color:#ed9d13">&#34;encoding/json&#34;</span>
<span style="color:#ed9d13">&#34;fmt&#34;</span>
<span style="color:#ed9d13">&#34;io/ioutil&#34;</span>
<span style="color:#ed9d13">&#34;log&#34;</span>
<span style="color:#ed9d13">&#34;net/http&#34;</span>
<span style="color:#ed9d13">&#34;time&#34;</span>
)
</code></pre></div><p>Tambien necesitamos escribir una estructura donde se extraera el texto del JSON, el nombre de las propiedades de la estructura deben iniciar con una letra mayúscula, para que puedan ser referenciadas como publicas</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6ab825;font-weight:bold">type</span> ship <span style="color:#6ab825;font-weight:bold">struct</span> {
     Flight_number <span style="color:#6ab825;font-weight:bold">int</span>    <span style="color:#ed9d13">`json:&#34;flight_number&#34;`</span>
     Mission_name  <span style="color:#6ab825;font-weight:bold">string</span> <span style="color:#ed9d13">`json:&#34;mission_name&#34;`</span>
     Details       <span style="color:#6ab825;font-weight:bold">string</span> <span style="color:#ed9d13">`json:&#34;details&#34;`</span>
 }
</code></pre></div><p>Realizamos el request y leemos la data con <strong>ioutil.ReadAll</strong></p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">     url := <span style="color:#ed9d13">&#34;https://api.spacexdata.com/v3/launches/latest&#34;</span>
     spaceX := http.Client{
         Timeout: time.Second * <span style="color:#3677a9">2</span>,
     }

     req, err := http.<span style="color:#447fcf">NewRequest</span>(http.MethodGet, url, <span style="color:#6ab825;font-weight:bold">nil</span>)
     <span style="color:#6ab825;font-weight:bold">if</span> err != <span style="color:#6ab825;font-weight:bold">nil</span> {
         log.<span style="color:#447fcf">Fatal</span>(err)
     }

     res, getErr := spaceX.<span style="color:#447fcf">Do</span>(req)
     <span style="color:#6ab825;font-weight:bold">if</span> getErr != <span style="color:#6ab825;font-weight:bold">nil</span> {
         log.<span style="color:#447fcf">Fatal</span>(getErr)
     }

     body, readErr := ioutil.<span style="color:#447fcf">ReadAll</span>(res.Body)
     <span style="color:#6ab825;font-weight:bold">if</span> readErr != <span style="color:#6ab825;font-weight:bold">nil</span> {
         log.<span style="color:#447fcf">Fatal</span>(readErr)
     }
</code></pre></div><p>Instanciamos ship1 con base a la estructura ship que escribimos anteriormente, posteriormente usamos json.Unmarshal para encodear la data y almacenarla en el objeto que instanciamos</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">&lt;pre class=<span style="color:#ed9d13">&#34;wp-block-code&#34;</span>&gt;&lt;code&gt;     ship1 := ship{}
     jsonErr := json.<span style="color:#447fcf">Unmarshal</span>(body, &amp;ship1)
     <span style="color:#6ab825;font-weight:bold">if</span> jsonErr != <span style="color:#6ab825;font-weight:bold">nil</span> {
         log.<span style="color:#447fcf">Fatal</span>(jsonErr)
     }

</code></pre></div><p>Por ultimo el resultado final que queremos mostrar:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">fmt.<span style="color:#447fcf">Println</span>(<span style="color:#ed9d13">&#34;Flight Number: &#34;</span>, ship1.Flight_number)
fmt.<span style="color:#447fcf">Println</span>(<span style="color:#ed9d13">&#34;Mission Name: &#34;</span>, ship1.Mission_name)
fmt.<span style="color:#447fcf">Println</span>(<span style="color:#ed9d13">&#34;Details: &#34;</span>, ship1.Details)
</code></pre></div><p>Nuestro código debe quedar algo asi:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6ab825;font-weight:bold">package</span> main

 <span style="color:#6ab825;font-weight:bold">import</span> (
     <span style="color:#ed9d13">&#34;encoding/json&#34;</span>
     <span style="color:#ed9d13">&#34;fmt&#34;</span>
     <span style="color:#ed9d13">&#34;io/ioutil&#34;</span>
     <span style="color:#ed9d13">&#34;log&#34;</span>
     <span style="color:#ed9d13">&#34;net/http&#34;</span>
     <span style="color:#ed9d13">&#34;time&#34;</span>
 )

 <span style="color:#6ab825;font-weight:bold">type</span> ship <span style="color:#6ab825;font-weight:bold">struct</span> {
     Flight_number <span style="color:#6ab825;font-weight:bold">int</span>    <span style="color:#ed9d13">`json:&#34;flight_number&#34;`</span>
     Mission_name  <span style="color:#6ab825;font-weight:bold">string</span> <span style="color:#ed9d13">`json:&#34;mission_name&#34;`</span>
     Details       <span style="color:#6ab825;font-weight:bold">string</span> <span style="color:#ed9d13">`json:&#34;details&#34;`</span>
 }

 <span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">main</span>() {

     url := <span style="color:#ed9d13">&#34;https://api.spacexdata.com/v3/launches/latest&#34;</span>
     spaceX := http.Client{
         Timeout: time.Second * <span style="color:#3677a9">2</span>,
     }

     req, err := http.<span style="color:#447fcf">NewRequest</span>(http.MethodGet, url, <span style="color:#6ab825;font-weight:bold">nil</span>)
     <span style="color:#6ab825;font-weight:bold">if</span> err != <span style="color:#6ab825;font-weight:bold">nil</span> {
         log.<span style="color:#447fcf">Fatal</span>(err)
     }

     res, getErr := spaceX.<span style="color:#447fcf">Do</span>(req)
     <span style="color:#6ab825;font-weight:bold">if</span> getErr != <span style="color:#6ab825;font-weight:bold">nil</span> {
         log.<span style="color:#447fcf">Fatal</span>(getErr)
     }

     body, readErr := ioutil.<span style="color:#447fcf">ReadAll</span>(res.Body)
     <span style="color:#6ab825;font-weight:bold">if</span> readErr != <span style="color:#6ab825;font-weight:bold">nil</span> {
         log.<span style="color:#447fcf">Fatal</span>(readErr)
     }
     ship1 := ship{}
     jsonErr := json.<span style="color:#447fcf">Unmarshal</span>(body, &amp;ship1)
     <span style="color:#6ab825;font-weight:bold">if</span> jsonErr != <span style="color:#6ab825;font-weight:bold">nil</span> {
         log.<span style="color:#447fcf">Fatal</span>(jsonErr)
     }
     fmt.<span style="color:#447fcf">Println</span>(<span style="color:#ed9d13">&#34;Flight Number: &#34;</span>, ship1.Flight_number)
     fmt.<span style="color:#447fcf">Println</span>(<span style="color:#ed9d13">&#34;Mission Name: &#34;</span>, ship1.Mission_name)
     fmt.<span style="color:#447fcf">Println</span>(<span style="color:#ed9d13">&#34;Details: &#34;</span>, ship1.Details)
 }
</code></pre></div><p>Guardamos y ejecutamos y debemos obtener un output como este:</p>
<pre><code class="language-code" data-lang="code">Flight Number:  74
Mission Name:  Iridium NEXT Mission 8
Details:  SpaceX's first flight of 2019 will be the eighth and final launch of its planned Iridium flights. Delivering 10 satellites to low earth orbit, this brings the total up to 75 and completes the Iridium NEXT constellation. This mission launches from SLC-4E at Vandenberg AFB. The booster is expected to land on JRTI.

</code></pre><p>Con esto, logramos escribir con Go un HTTP Client que realiza un Request para consumir la API de spaceX y obtener un poco de información de la ultima nave lanzada al espacio.</p>
<p>Mas información</p>
<p><a href="https://golang.org/doc/">https://golang.org/doc/</a></p>]]></content>
        </item>
        
        <item>
            <title>Creando un cluster de kubernetes en GCP con terraform</title>
            <link>/posts/creando-un-cluster-de-kubernetes-en-gcp-con-terraform/</link>
            <pubDate>Sun, 03 Feb 2019 21:44:10 +0000</pubDate>
            
            <guid>/posts/creando-un-cluster-de-kubernetes-en-gcp-con-terraform/</guid>
            <description>&lt;p&gt;&lt;img src=&#34;/images/terra-gcp-kubernetes2.png&#34; alt=&#34;Kubernetes&#34;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;Terraform, es una de las herramientas mas potentes de hashicorp y hoy en día es usada por grandes compañías para mantener infraestructura en la nube.&lt;/p&gt;
&lt;p&gt;Terraform destaca porque podemos trabajar con múltiples providers al mismo tiempo, ¿ que quiere decir esto ? que le podemos decir a terraform que cuando se cree una nueva instancia en GCP al mismo tiempo  genere un registro DNS en route53 en AWS, esto de una manera muy sencilla.&lt;/p&gt;
&lt;p&gt;Pero hoy no vamos a hablar de AWS, hoy vamos a hablar de GCP, una nube muy poderosa que tiene características muy interesantes para tener en cuenta y en este caso, construiremos un cluster de Kubernetes en GCP usando terraform.&lt;/p&gt;
&lt;h3 id=&#34;conectandonos-a-google-cloud-platform&#34;&gt;Conectandonos a Google Cloud platform:&lt;/h3&gt;
&lt;p&gt;Para conectarnos a GCP solo necesitamos determinar:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Credentials&lt;/strong&gt; : En este caso tenemos que generar un account service y usar el archivo json que se genera con los permisos necesarios&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project&lt;/strong&gt;  : Determinamos el proyecto en GCP en el cual vamos a trabajar&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;region&lt;/strong&gt; : Determinamos la región por el cual vamos a trabajar.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Despues de determinar los valores mencionados anteriormente, los seteamos en el siguiente archivo.&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p><img src="/images/terra-gcp-kubernetes2.png" alt="Kubernetes"></p>
<p> </p>
<p>Terraform, es una de las herramientas mas potentes de hashicorp y hoy en día es usada por grandes compañías para mantener infraestructura en la nube.</p>
<p>Terraform destaca porque podemos trabajar con múltiples providers al mismo tiempo, ¿ que quiere decir esto ? que le podemos decir a terraform que cuando se cree una nueva instancia en GCP al mismo tiempo  genere un registro DNS en route53 en AWS, esto de una manera muy sencilla.</p>
<p>Pero hoy no vamos a hablar de AWS, hoy vamos a hablar de GCP, una nube muy poderosa que tiene características muy interesantes para tener en cuenta y en este caso, construiremos un cluster de Kubernetes en GCP usando terraform.</p>
<h3 id="conectandonos-a-google-cloud-platform">Conectandonos a Google Cloud platform:</h3>
<p>Para conectarnos a GCP solo necesitamos determinar:</p>
<ul>
<li><strong>Credentials</strong> : En este caso tenemos que generar un account service y usar el archivo json que se genera con los permisos necesarios</li>
<li><strong>Project</strong>  : Determinamos el proyecto en GCP en el cual vamos a trabajar</li>
<li><strong>region</strong> : Determinamos la región por el cual vamos a trabajar.</li>
</ul>
<p>Despues de determinar los valores mencionados anteriormente, los seteamos en el siguiente archivo.</p>
<p><strong>variables.tf</strong></p>
<p>En este archivo determinaremos las variables que vamos a necesitar</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">// General Variables

variable <span style="color:#ed9d13">&#34;credentials&#34;</span> {
<span style="color:#24909d">type</span> = <span style="color:#ed9d13">&#34;string&#34;</span>
<span style="color:#40ffff">default</span> = <span style="color:#ed9d13">&#34;../key.json&#34;</span>
<span style="color:#40ffff">description</span> = <span style="color:#ed9d13">&#34;Json Credentials file to connect GCP&#34;</span>
}

variable <span style="color:#ed9d13">&#34;linux_admin_username&#34;</span> {
<span style="color:#24909d">type</span> = <span style="color:#ed9d13">&#34;string&#34;</span>
<span style="color:#40ffff">description</span> = <span style="color:#ed9d13">&#34;User name for authentication to the Kubernetes linux agent virtual machines in the cluster.&#34;</span>
<span style="color:#40ffff">default</span> = <span style="color:#ed9d13">&#34;glb-events&#34;</span>
}

variable <span style="color:#ed9d13">&#34;linux_admin_password&#34;</span> {
<span style="color:#24909d">type</span> =<span style="color:#ed9d13">&#34;string&#34;</span>
<span style="color:#40ffff">default</span> = <span style="color:#ed9d13">&#34;MySecretPassTest123.&#34;</span>
<span style="color:#40ffff">description</span> = <span style="color:#ed9d13">&#34;The password for the Linux admin account.&#34;</span>
}

// GCP Variables
variable <span style="color:#ed9d13">&#34;gcp_cluster_count&#34;</span> {
<span style="color:#24909d">type</span> = <span style="color:#ed9d13">&#34;string&#34;</span>
<span style="color:#40ffff">description</span> = <span style="color:#ed9d13">&#34;Count of cluster instances to start.&#34;</span>
<span style="color:#40ffff">default</span> = <span style="color:#ed9d13">&#34;1&#34;</span>
}
variable <span style="color:#ed9d13">&#34;project&#34;</span> {
  <span style="color:#24909d">type</span> = <span style="color:#ed9d13">&#34;string&#34;</span>
  <span style="color:#40ffff">default</span> = <span style="color:#ed9d13">&#34;MyProjectID&#34;</span>
}

variable <span style="color:#ed9d13">&#34;cluster_name&#34;</span> {
<span style="color:#24909d">type</span> = <span style="color:#ed9d13">&#34;string&#34;</span>
<span style="color:#40ffff">description</span> = <span style="color:#ed9d13">&#34;Cluster name for the GCP Cluster.&#34;</span>
<span style="color:#40ffff">default</span> = <span style="color:#ed9d13">&#34;stack-kubernetes&#34;</span>
}
</code></pre></div><p>Despues seteamos el siguiente archivo el cual vamos a llamar las variables escritas en el archivo variables.tf,  en este archivo le diremos a terraform que trabajaremos con el provider de <strong>Google Cloud Platform</strong></p>
<p><strong>main.tf</strong></p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">provider <span style="color:#ed9d13">&#34;google&#34;</span> {
  <span style="color:#40ffff">credentials</span> = <span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">${</span><span style="color:#40ffff">file</span>(var.credentials)<span style="color:#ed9d13">}</span><span style="color:#ed9d13">&#34;</span>
  <span style="color:#40ffff">project</span>     = <span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">${</span><span style="color:#40ffff">var</span>.project<span style="color:#ed9d13">}</span><span style="color:#ed9d13">&#34;</span>
  <span style="color:#40ffff">region</span>      = <span style="color:#ed9d13">&#34;us-west1&#34;</span>
}
</code></pre></div><p>Ahora escribimos el siguiente archivo, en este archivo creamos el cluster de Kubernetes y definiremos diferentes atributos necesarios:</p>
<p><strong>kubernetes.tf</strong></p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">resource <span style="color:#ed9d13">&#34;google_container_cluster&#34;</span> <span style="color:#ed9d13">&#34;gcp_kubernetes&#34;</span> {
   <span style="color:#40ffff">name</span>               = <span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">${</span><span style="color:#40ffff">var</span>.cluster_name<span style="color:#ed9d13">}</span><span style="color:#ed9d13">&#34;</span>
   <span style="color:#40ffff">zone</span>               = <span style="color:#ed9d13">&#34;us-west1-a&#34;</span>
   <span style="color:#40ffff">initial_node_count</span> = <span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">${</span><span style="color:#40ffff">var</span>.gcp_cluster_count<span style="color:#ed9d13">}</span><span style="color:#ed9d13">&#34;</span>

   <span style="color:#40ffff">additional_zones</span> = [
     <span style="color:#ed9d13">&#34;us-west1-b&#34;</span>,
     <span style="color:#ed9d13">&#34;us-west1-c&#34;</span>,
   ]

   master_auth {
     <span style="color:#40ffff">username</span> = <span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">${</span><span style="color:#40ffff">var</span>.linux_admin_username<span style="color:#ed9d13">}</span><span style="color:#ed9d13">&#34;</span>
     <span style="color:#40ffff">password</span> = <span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">${</span><span style="color:#40ffff">var</span>.linux_admin_password<span style="color:#ed9d13">}</span><span style="color:#ed9d13">}&#34;</span>
   }

   node_config {
     <span style="color:#40ffff">oauth_scopes</span> = [
       <span style="color:#ed9d13">&#34;https://www.googleapis.com/auth/compute&#34;</span>,
       <span style="color:#ed9d13">&#34;https://www.googleapis.com/auth/devstorage.read_only&#34;</span>,
       <span style="color:#ed9d13">&#34;https://www.googleapis.com/auth/logging.write&#34;</span>,
       <span style="color:#ed9d13">&#34;https://www.googleapis.com/auth/monitoring&#34;</span>,
     ]

     labels {
       this-is-for = <span style="color:#ed9d13">&#34;dev-cluster&#34;</span>
     }

     <span style="color:#40ffff">tags</span> = [<span style="color:#ed9d13">&#34;dev&#34;</span>, <span style="color:#ed9d13">&#34;work&#34;</span>]
   }
 }


     <span style="color:#999;font-style:italic">## Connect to cluster after creating it</span>

 resource <span style="color:#ed9d13">&#34;null_resource&#34;</span> <span style="color:#ed9d13">&#34;connect-cluster&#34;</span> {
 <span style="color:#40ffff">depends_on</span> = [<span style="color:#ed9d13">&#34;google_container_cluster.gcp_kubernetes&#34;</span>]
 provisioner <span style="color:#ed9d13">&#34;local-exec&#34;</span> {
     <span style="color:#24909d">command</span> = <span style="color:#ed9d13">&#34;gcloud container clusters get-credentials </span><span style="color:#ed9d13">${</span><span style="color:#40ffff">var</span>.cluster_name<span style="color:#ed9d13">}</span><span style="color:#ed9d13"> --zone us-west1-a --project academy-193615&#34;</span>
     <span style="color:#40ffff">interpreter</span> = [<span style="color:#ed9d13">&#34;bash&#34;</span>, <span style="color:#ed9d13">&#34;-c&#34;</span>]
 }
 }
</code></pre></div><p>Una breve descripción de algunos atributos:</p>
<p>**name: ** Nombre del cluster que estamos creando, este valor lo definimos anteriormente en <strong>variables.tf</strong></p>
<p>**initial_node_count: ** numero de instancias que se desplegaran por zonas, en este caso se desplegara una instancia por cada zona que definimos.</p>
<p>**oauth_scopes: ** Scopes necesarios para el buen funcionamiento de kubernetes y acceso a otros recursos.</p>
<p> </p>
<p>Por ultimo, en este archivo se encuentra un recurso un poco particular ya que es un recurso tipo “null_resource” este recurso nos permite ejecutar comandos</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">gcloud container clusters get-credentials <span style="color:#ed9d13">${</span><span style="color:#40ffff">var</span>.cluster_name<span style="color:#ed9d13">}</span> --zone us-west1-a --project academy-193615
</code></pre></div><p>Concluire que si ya hemos trabajado en GCP ya hemos realizado el join de gcloud de nuestra CLI asi que me saltare ese paso.</p>
<p>Con este comando le decimos a gcloud que establezcla la conexión de manera local a nuestro stack de kubernetes, asi que si queremos correr algun comando de kubectl hacia nuestro stack podemos hacerlo de manera local sin ningun inconveniente.</p>
<p>Ahora que todo esta listo, ejecutamos el siguiente comando para que terraform verifique los recursos a crear.</p>
<p><strong>terraform plan</strong></p>
<p>Si todo sale bien, se debe observar lo siguiente:</p>
<p><img src="/images/terra-gcp-kubernetes-image2.png" alt="image2"></p>
<p>Terraform verifica los recursos escritos en los archivos tf y su estado, en este momento el estado del cluster es que no esta creado y terraform, procedera a crearla. Para crear los recursos ejecutamos el siguiente comando:</p>
<p><strong>terraform apply</strong></p>
<p>Si los recursos se crearon satisfactoriamente, tendremos un output parecido a este:</p>
<p><img src="/images/terra-gcp-kubernetes-image3.png" alt="image3"></p>
<p>Verificamos los nodos de nuestro cluster:</p>
<p><strong>kubect get nodes</strong></p>
<p><img src="/images/terra-gcp-kubernetes-image4.png" alt="image4"></p>
<p><img src="/images/terra-gcp-kubernetes-image5.png" alt="image5"></p>
<p>De este modo desplegamos un stack de Kubernetes en GCP en segundos, listo para desplegar nuestros servicios.</p>
<p>Mas información:</p>
<p><a href="https://www.terraform.io/docs/">https://www.terraform.io/docs/</a></p>
<p><a href="https://kubernetes.io/docs/home/">https://kubernetes.io/docs/home/</a></p>]]></content>
        </item>
        
        <item>
            <title>Utilizando Traefik como Dynamic Reverse Proxy en Docker Swarm sobre  AWS</title>
            <link>/posts/utilizando-traefik-como-dynamic-reverse-proxy-en-docker-swarm-sobre-aws/</link>
            <pubDate>Fri, 22 Dec 2017 01:20:18 +0000</pubDate>
            
            <guid>/posts/utilizando-traefik-como-dynamic-reverse-proxy-en-docker-swarm-sobre-aws/</guid>
            <description>&lt;p&gt;&lt;img src=&#34;/images/traefik.png&#34; alt=&#34;image1&#34;&gt;&lt;/p&gt;
&lt;p&gt;Traefik es una herramienta muy potente gracias a que soporta varios providers como backend, en este caso usaremos traefik para que nos sirva como &lt;strong&gt;Dynamic Reverse Proxy&lt;/strong&gt; sobre un cluster de &lt;strong&gt;Docker Swarm&lt;/strong&gt; en &lt;strong&gt;Amazon Web Services&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes:&lt;/h3&gt;
&lt;h4 id=&#34;3-instancias-1-manager-y-2-worker&#34;&gt;3 Instancias (1 Manager  y 2 worker):&lt;/h4&gt;
&lt;p&gt;**Manager: **Esta instancia sera la que controlara todo el cluster, en ella desplegaremos traefik y los servicios que no son worker, esta instancia estará sobre una subnet , la cual llamaremos **“subnet frontend” **y tendrá su respectivo Secure Group&lt;/p&gt;
&lt;p&gt;**Worker: **las instancias llamadas workers son dichas instancias donde correran nuestros servicios desplegados en AWS, sin tener en cuenta los servicios de “management” que podemos desplegar en la subnet de frontend, aquí desplegaremos los servicios que necesitemos como un web server, un micro servicio, etc, estas dos instancias estarán sobre otra subnet, la cual la llamaremos &lt;strong&gt;“subnet backend”&lt;/strong&gt; y tendrá su respectivo Secure Group&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p><img src="/images/traefik.png" alt="image1"></p>
<p>Traefik es una herramienta muy potente gracias a que soporta varios providers como backend, en este caso usaremos traefik para que nos sirva como <strong>Dynamic Reverse Proxy</strong> sobre un cluster de <strong>Docker Swarm</strong> en <strong>Amazon Web Services</strong>.</p>
<h3 id="componentes">Componentes:</h3>
<h4 id="3-instancias-1-manager-y-2-worker">3 Instancias (1 Manager  y 2 worker):</h4>
<p>**Manager: **Esta instancia sera la que controlara todo el cluster, en ella desplegaremos traefik y los servicios que no son worker, esta instancia estará sobre una subnet , la cual llamaremos **“subnet frontend” **y tendrá su respectivo Secure Group</p>
<p>**Worker: **las instancias llamadas workers son dichas instancias donde correran nuestros servicios desplegados en AWS, sin tener en cuenta los servicios de “management” que podemos desplegar en la subnet de frontend, aquí desplegaremos los servicios que necesitemos como un web server, un micro servicio, etc, estas dos instancias estarán sobre otra subnet, la cual la llamaremos <strong>“subnet backend”</strong> y tendrá su respectivo Secure Group</p>
<p>Es necesario abrir estos puertos entre los  secure group frontend y backend para permitir la comunicación del cluster</p>
<ul>
<li>2377/tcp</li>
<li>7946/tcp-udp</li>
<li>4789/udp</li>
</ul>
<p>Ya teniendo en cuenta los componentes, iniciemos:</p>
<h3 id="instalación-de-docker-y-despliegue-de-docker-swarm">Instalación de Docker y despliegue de Docker Swarm</h3>
<p>Voy a concluir que ya se tiene desplegadas las instancias en cada subnet y se utilizo la ami de amazon linux, para instalar docker y dejarlo corriendo sin problemas es necesario ejecutar los siguientes comandos en las 3 instancias <strong>( Manager  y workers )</strong></p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo yum install docker
sudo service docker start
sudo chkconfig docker on
</code></pre></div><p>Con estos comandos, docker ya esta instalado, ahora si, vamos a crear un cluster de Docker Swarm</p>
<h3 id="inicializando-el-cluster">Inicializando el Cluster</h3>
<p>Ejecutaremos este comando en la instancia “Manager” para inicializar el Swarm Cluster y obtener el token</p>
<!-- raw HTML omitted -->
<p>Obtendremos un output parecido a este:</p>
<p><img src="/images/traefik1.png" alt="image1"></p>
<p>El output nos genera un token, este token lo usamos para unir los worker al cluster, ahora ejecutamos el siguiente comando en cada worker ( cambiando la ip de su respectiva instancia )</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>En cada worker cambiar:</p>
<p><strong>ip-worker:  la ip del worker</strong></p>
<p>Después de ejecutar el comando anterior tendremos un output el cual nos dice que el nodo ingreso al cluster como worker:</p>
<p><strong>“This node joined a swarm as a worker.”</strong></p>
<p>Para verificar que docker Swarm pueda ver los nodos ejecutamos el siguiente comando en el manager para ver los nodos:</p>
<!-- raw HTML omitted -->
<p><img src="/images/traefik2.png" alt="images3"></p>
<p>Finalmente, creamos una red tipo overlay para nuestro cluster, ejecutamos el siguiente comando desde el manager:</p>
<!-- raw HTML omitted -->
<h3 id="desplegando-traefik-en-nuestro-swarm-cluster">Desplegando Traefik en nuestro Swarm Cluster</h3>
<p>Ya que tenemos listo nuestro Swarm Cluster, desde nuestro Manager vamos a desplegar nuestro Traefik, el cual se encargara de recibir todos los request y enviarlo a su respectivo container.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Con el comando anterior, le decimos a docker que nos despliegue un nuevo servicio llamado traefik, nos publique el puerto 80 para recibir los request y el puerto 8080 para acceder al dashboard, tambien se especifica la red a utilizar, se especifica que es un servicio <strong>“manager”</strong> y  por ultimo los diferentes parámetros de docker swarm.</p>
<p>SI el comando anterior no genera ningun error, podemos ejecutar el siguiente comando para observar si el servicio fue desplegado.</p>
<!-- raw HTML omitted -->
<p><img src="/images/traefik3.png" alt="image3"></p>
<p>Como se observa en la imagen, vemos que se encuentra el servicio traefik desplegado y a la escucha de request por el puerto 80</p>
<h3 id="desplegando-nuestras-aplicaciones">Desplegando nuestras aplicaciones</h3>
<p>Ya que tenemos nuestro Traefik funcionando en nuestro Swarm Cluster, podemos desplegar nuestras aplicaciones para que traefik haga balanceo del trafico, en este caso, volveré a usar la imagen de katacoda <strong>docker-http-server</strong></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>En el despliegue del servicio app01 utilizamos varios label, los mas importantes son **traefik.port=80 **el cual le decimos a traefik el puerto a usar y **traefik.frontend.rule=Host:app01.braybaut.co **con este label, le decimos a traefik que todo el trafico que llegue a **app01.braybaut.com **debe ser redireccionado a los container que hagan parte de ese servicio <strong>app01</strong></p>
<p>Desplegamos otro servicio el cual sera **app02 **y el endpoint sera: <strong>app02.braybaut.com</strong></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Observamos los servicios desplegados:
<img src="/images/traefik4.png" alt="image4"></p>
<p>Observamos que tenemos nuestro traefik y  nuestras dos apps (app01 y app02)</p>
<p>Con esto, logramos desplegar dos apps en nuestro Swarm Cluster, ahora, podemos acceder desde nuestro balanceador a nuestras dos Apps.</p>
<p><img src="/images/traefik5.png" alt="image4"></p>
<p>Con los anteriores Request, observamos que app01 se esta ejecutando en el contenedor d066207b1e23  y el app02 corre en el contenedor 80f164e6b5de</p>
<p>Cada contenedor se encuentra en una worker diferente:</p>
<!-- raw HTML omitted -->
<p>Podemos escalar  nuestros servicios y observar como funciona el balanceo de nuestro traefik:</p>
<p>Escalamos app01 a 4 containers</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Realizamos peticiones a nuestro app con el endpoint app01.braybaut.com</p>
<p><img src="/images/traefik7.png" alt="image4"></p>
<p>Como se observa en la imagen, en cada request responde un container diferente, esto quiere decir que traefik realiza el balanceo del trafico de una manera correcta.</p>
<p>Vemos que nuestro servicio se encuentra escalado:</p>
<!-- raw HTML omitted -->
<p>Esto es todo, traefik balancea nuestro trafico de una manera dinámica, sin importar el momento en que nuestro servicio escale, traefik sera capas de reconocer los nuevos container y balancear dicho trafico.</p>
<p>Mas información:</p>
<p><a href="https://docs.docker.com/engine/swarm/">https://docs.docker.com/engine/swarm/</a></p>
<p><a href="https://docs.docker.com/engine/swarm/">https://docs.traefik.io/</a></p>]]></content>
        </item>
        
        <item>
            <title>Traefik: Load Balancer y Reverse Proxy para Docker</title>
            <link>/posts/traefik-load-balancer-y-reverse-proxy-para-docker/</link>
            <pubDate>Wed, 25 Oct 2017 22:25:26 +0000</pubDate>
            
            <guid>/posts/traefik-load-balancer-y-reverse-proxy-para-docker/</guid>
            <description>&lt;p&gt;&lt;img src=&#34;/images/traefik.png&#34; alt=&#34;image1&#34;&gt;&lt;/p&gt;
&lt;p&gt;Cuando trabajamos con docker en ambientes productivos, la mayoría de casos usamos tecnologías para orquestar y poder ofrecer alta disponibilidad sobre nuestros micro servicios, debido a esto, nosotros corremos multiples aplicaciones sobre un mismo host que haga parte de nuestro stack de orquestación. Para que estas aplicaciones puedan ser consumidas sin necesidad de exponer un puerto, necesitamos un reverse proxy para poder consumir estos servicios desde un único puerto.&lt;/p&gt;
&lt;p&gt;**Traefik **es un reverse proxy  y load balancer compatible con docker escrito en Go, creado especialmente para micro servicios, Traefik soporta diferentes Backends como: &lt;strong&gt;(Docker, docker Swarm, Kubernetes, Rancher, Amazon ECS y muchos mas )&lt;/strong&gt; su configuración es bastante sencilla y cuenta con un Dashboard donde podemos visualizar nuestros Micro servicios.&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p><img src="/images/traefik.png" alt="image1"></p>
<p>Cuando trabajamos con docker en ambientes productivos, la mayoría de casos usamos tecnologías para orquestar y poder ofrecer alta disponibilidad sobre nuestros micro servicios, debido a esto, nosotros corremos multiples aplicaciones sobre un mismo host que haga parte de nuestro stack de orquestación. Para que estas aplicaciones puedan ser consumidas sin necesidad de exponer un puerto, necesitamos un reverse proxy para poder consumir estos servicios desde un único puerto.</p>
<p>**Traefik **es un reverse proxy  y load balancer compatible con docker escrito en Go, creado especialmente para micro servicios, Traefik soporta diferentes Backends como: <strong>(Docker, docker Swarm, Kubernetes, Rancher, Amazon ECS y muchos mas )</strong> su configuración es bastante sencilla y cuenta con un Dashboard donde podemos visualizar nuestros Micro servicios.</p>
<h2 id="demo"><strong>Demo:</strong></h2>
<p>En este caso desplegare dos web servers  en docker que van a ser manejados por traefik.</p>
<p><strong>Web Server 1:</strong> blog1.braybaut.com</p>
<p><strong>Web Server 2 :</strong> blog2.braybaut.com</p>
<p><strong>docker-compose.yml:</strong></p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#666">  </span><span style="color:#6ab825;font-weight:bold">image</span>:<span style="color:#666"> </span>traefik<span style="color:#666">
</span><span style="color:#666">  </span><span style="color:#6ab825;font-weight:bold">command</span>:<span style="color:#666"> </span>--web<span style="color:#666"> </span>--docker<span style="color:#666"> </span>--docker.domain=docker.localhost<span style="color:#666"> </span>--logLevel=DEBUG<span style="color:#666">
</span><span style="color:#666">  </span><span style="color:#6ab825;font-weight:bold">ports</span>:<span style="color:#666">
</span><span style="color:#666">    </span>- <span style="color:#ed9d13">&#34;80:80&#34;</span><span style="color:#666">
</span><span style="color:#666">    </span>- <span style="color:#ed9d13">&#34;8080:8080&#34;</span><span style="color:#666">
</span><span style="color:#666">    </span>- <span style="color:#ed9d13">&#34;443:443&#34;</span><span style="color:#666">
</span><span style="color:#666">  </span><span style="color:#6ab825;font-weight:bold">volumes</span>:<span style="color:#666">
</span><span style="color:#666">    </span>- /var/run/docker.sock:/var/run/docker.sock<span style="color:#666">
</span><span style="color:#666">    </span>- /dev/<span style="color:#6ab825;font-weight:bold">null</span>:/traefik.toml<span style="color:#666">
</span><span style="color:#666">
</span><span style="color:#666">
</span><span style="color:#666"></span><span style="color:#6ab825;font-weight:bold">machine1</span>:<span style="color:#666">
</span><span style="color:#666">  </span><span style="color:#6ab825;font-weight:bold">image</span>:<span style="color:#666"> </span>katacoda/docker-http-server<span style="color:#666">
</span><span style="color:#666">  </span><span style="color:#6ab825;font-weight:bold">labels</span>:<span style="color:#666">
</span><span style="color:#666">    </span>- <span style="color:#ed9d13">&#34;traefik.backend=blog1&#34;</span><span style="color:#666">
</span><span style="color:#666">    </span>- <span style="color:#ed9d13">&#34;traefik.frontend.rule=Host:blog1.braybaut.com&#34;</span><span style="color:#666">
</span><span style="color:#666">
</span><span style="color:#666"></span><span style="color:#6ab825;font-weight:bold">machine2</span>:<span style="color:#666">
</span><span style="color:#666">  </span><span style="color:#6ab825;font-weight:bold">image</span>:<span style="color:#666"> </span>katacoda/docker-http-server:v2<span style="color:#666">
</span><span style="color:#666">  </span><span style="color:#6ab825;font-weight:bold">labels</span>:<span style="color:#666">
</span><span style="color:#666">    </span>- <span style="color:#ed9d13">&#34;traefik.backend=blog2&#34;</span><span style="color:#666">
</span><span style="color:#666">    </span>- <span style="color:#ed9d13">&#34;traefik.frontend.rule=Host:blog2.braybaut.com&#34;</span><span style="color:#666">
</span></code></pre></div><p>Este docker-compose es muy fácil de interpretar, en el despliegue del container de  traefik el usa el docker.sock para permitir que traefik escuche los eventos del daemon de Docker, re configurarse cuando los containers se inician y se detienen y para utilizar algunos meta datos que este daemon pueda ofrecer, como por ejemplo el nombre de los containers. Para los web Servers use la imagen de Kataconda el cual es ideal para este ejemplo, estos containers usan varios label lo cual permiten cambiar su configuración para el uso de traefik</p>
<p>Algunos label:</p>
<ul>
<li>traefik.port</li>
<li>traefik.protoco</li>
<li>traefik.weight</li>
<li>traefik.frontend.rule</li>
<li>traefik.docker.network</li>
<li>traefik.backend</li>
</ul>
<p>En el caso de <strong>traefik.frontend.rule</strong> especificamos el dominio por el cual nos llegara la petición desde el frontend, en este caso: blog1.braybaut.com y blog2.braybaut.com</p>
<p>Despues de definir el docker-compose, despliegamos los container mencionados en el yaml file:</p>
<pre><code class="language-code" data-lang="code">docker-compose up -d
</code></pre><p>Si los containers se desplegaron sin inconvenientes, tendremos este output:</p>
<p><img src="/images/traefik9.png" alt=""></p>
<p>Ahora, podemos hacer peticiones con curl a blog1.braybaut.com y blog2.braybaut.com y nos debe responder cada container.</p>
<p><img src="/images/traefik10.png" alt=""></p>
<p>Como observamos vemos que cada peticion  me responde con el ID de su respectivo container** 873c9508bef7   8f3c982a1949</p>
<h3 id="escalando-nuestromicro-servicio">Escalando nuestro Micro servicio:</h3>
<p>Como mencione al inicio de esta publicación, traefik también es un <strong>load Balancer</strong> y maneja diferentes técnicas de balanceo, ya que estamos usando docker compose para este ejemplo, escalare un web server <strong>Machine1</strong>.</p>
<pre><code class="language-console" data-lang="console">docker-compose scale machine1=2&lt;/pre&gt;
</code></pre><p><img src="/images/traefik11.png" alt=""></p>
<p>Micro servicio escalado, ahora debemos tener dos containers de este micro servicio <strong>“machine1”</strong> en ejecución:</p>
<p><img src="/images/traefik12.png" alt=""></p>
<p>Ahora, como nuestro traefik esta balanceando el trafico de este servicio **machine1 **por medio del domain **blog1.braybaut.com **al volver a realizar una petición por curl nos debe responder cada contenedor:</p>
<p><img src="/images/traefik13.png" alt=""></p>
<p>Como observamos, por cada petición a <strong>blog1.braybaut.com</strong> nos va a responder un container diferente:  **cebaede35153  cad89564505e  ** Con esto, logramos un load balancer automático cuando necesitemos hacer scaling de nuestros micro servicios.</p>
<p>No olvidar que tenemos un Dashboard donde podemos ver nuestros Micro servicios manejados por Traefik:</p>
<p>“Podemos acceder a este Dashboard por el puerto 8080”</p>
<p><img src="/images/traefik13.png" alt=""></p>
<p>Próximamente escribiré como usar traefik usando Amazon ECS  y Docker Swarm como Backend.</p>
<p>Mas información:</p>
<p><a href="https://traefik.io/">https://traefik.io/</a></p>
<p><a href="https://docs.traefik.io/">https://docs.traefik.io/</a></p>]]></content>
        </item>
        
        <item>
            <title>Howto: Instalando Rocket.Chat en Docker</title>
            <link>/posts/howto-instalando-rocket.chat-en-docker/</link>
            <pubDate>Tue, 07 Mar 2017 06:54:30 +0000</pubDate>
            
            <guid>/posts/howto-instalando-rocket.chat-en-docker/</guid>
            <description>&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Rocket.chat para mi es una de las mejores plataformas de chat &lt;strong&gt;OpenSource&lt;/strong&gt; que existen, es muy flexible a la hora de adaptarlo y lo mejor, tiene cliente para toda las plataformas.&lt;/p&gt;
&lt;p&gt;En este caso, realizaremos la instalación de Rocket.chat en &lt;strong&gt;docker&lt;/strong&gt;, por el cual no importara la distribución linux que utilicemos, pero en este caso utilizare Centos 7 como host de mis contenedores para hacer el despliegue.&lt;/p&gt;
&lt;h2 id=&#34;instalación&#34;&gt;Instalación:&lt;/h2&gt;
&lt;p&gt;Vamos a usar varios contenedores y para lograr la comunicación entre ellos, se usara &lt;strong&gt;Docker Compose&lt;/strong&gt;, el cual nos permite hacer despliegues de servicios el cual involucra varios contenedores.&lt;/p&gt;
&lt;h3 id=&#34;docker&#34;&gt;Docker:&lt;/h3&gt;
&lt;p&gt;Instalamos docker usando el script que se encuentra en su pagina oficial.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;wget -qO- https://get.docker.com/ | sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Al finalizar el proceso usamos systemctl para subir el servicio y dejarlo habilitado para que inicie cuando se inicie el servidor.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;systemctl start enable

systemcl enable docker
&lt;/code&gt;&lt;/pre&gt;</description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<p>Rocket.chat para mi es una de las mejores plataformas de chat <strong>OpenSource</strong> que existen, es muy flexible a la hora de adaptarlo y lo mejor, tiene cliente para toda las plataformas.</p>
<p>En este caso, realizaremos la instalación de Rocket.chat en <strong>docker</strong>, por el cual no importara la distribución linux que utilicemos, pero en este caso utilizare Centos 7 como host de mis contenedores para hacer el despliegue.</p>
<h2 id="instalación">Instalación:</h2>
<p>Vamos a usar varios contenedores y para lograr la comunicación entre ellos, se usara <strong>Docker Compose</strong>, el cual nos permite hacer despliegues de servicios el cual involucra varios contenedores.</p>
<h3 id="docker">Docker:</h3>
<p>Instalamos docker usando el script que se encuentra en su pagina oficial.</p>
<pre><code class="language-console" data-lang="console">wget -qO- https://get.docker.com/ | sh
</code></pre><p>Al finalizar el proceso usamos systemctl para subir el servicio y dejarlo habilitado para que inicie cuando se inicie el servidor.</p>
<pre><code class="language-console" data-lang="console">systemctl start enable

systemcl enable docker
</code></pre><h3 id="docker-compose">Docker Compose:</h3>
<p>Hacemos uso de la ultima versión estable de docker compose que se encuentra en  github y dejamos el script en <strong>/usr/local/bin/docker-compose</strong></p>
<pre><code class="language-console" data-lang="console">curl -L &quot;https://github.com/docker/compose/releases/download/1.11.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose
</code></pre><p>Aplicamos permisos de ejecución:</p>
<pre><code class="language-console" data-lang="console">chmod +x /usr/local/bin/docker-compose 
</code></pre><p>Verificamos la versión de docker-compose para mirar que se instalo la versión correcta:</p>
<pre><code class="language-console" data-lang="console">docker-compose --version
</code></pre><p><img src="/images/rocketchat2.png" alt=""></p>
<p>Ya que tenemos docker y docker-compose instalado, vamos a preparar el <strong>docker-compose.yml</strong> necesario para el despliegue de los contenedores y los directorios locales donde se almacenara la data.</p>
<h3 id="creando-los-directorios-locales-">Creando los directorios locales :</h3>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">mkdir -p /opt/rocket.chat/data/runtime/db
mkdir -p /opt/rocket.chat/data/dump
</code></pre></div><h3 id="creando-el-docker-composeyaml">Creando el docker-compose.yaml</h3>
<p>Creamos y editamos el archivo docker-compose.yml</p>
<pre><code class="language-console" data-lang="console">vim /opt/rocket.chat/docker-compose.yml
</code></pre><div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#666">  </span><span style="color:#6ab825;font-weight:bold">image</span>:<span style="color:#666"> </span>mongo<span style="color:#666">
</span><span style="color:#666">  </span><span style="color:#6ab825;font-weight:bold">volumes</span>:<span style="color:#666">
</span><span style="color:#666">    </span>- ./data/runtime/db:/data/db<span style="color:#666">
</span><span style="color:#666">    </span>- ./data/dump:/dump<span style="color:#666">
</span><span style="color:#666">  </span><span style="color:#6ab825;font-weight:bold">command</span>:<span style="color:#666"> </span>mongod<span style="color:#666"> </span>--smallfiles<span style="color:#666">
</span><span style="color:#666"></span><span style="color:#6ab825;font-weight:bold">rocketchat</span>:<span style="color:#666">
</span><span style="color:#666">  </span><span style="color:#6ab825;font-weight:bold">image</span>:<span style="color:#666"> </span>rocketchat/rocket.chat:latest<span style="color:#666">
</span><span style="color:#666">  </span><span style="color:#6ab825;font-weight:bold">environment</span>:<span style="color:#666">
</span><span style="color:#666">    </span>- MONGO_URL=mongodb://db:<span style="color:#3677a9">27017</span>/rocketchat<span style="color:#666">
</span><span style="color:#666">    </span>- ROOT_URL=http://chat.braybaut.com<span style="color:#666">
</span><span style="color:#666">    </span>- Accounts_UseDNSDomainCheck=True<span style="color:#666">
</span><span style="color:#666">  </span><span style="color:#6ab825;font-weight:bold">links</span>:<span style="color:#666">
</span><span style="color:#666">    </span>- db:db<span style="color:#666">
</span><span style="color:#666">  </span><span style="color:#6ab825;font-weight:bold">ports</span>:<span style="color:#666">
</span><span style="color:#666">    </span>- <span style="color:#3677a9">3000</span>:<span style="color:#3677a9">3000</span><span style="color:#666">
</span><span style="color:#666"></span><span style="color:#6ab825;font-weight:bold">hubot</span>:<span style="color:#666">
</span><span style="color:#666">  </span><span style="color:#6ab825;font-weight:bold">image</span>:<span style="color:#666"> </span>rocketchat/hubot-rocketchat:v0<span style="color:#3677a9">.1.4</span><span style="color:#666">
</span><span style="color:#666">  </span><span style="color:#6ab825;font-weight:bold">environment</span>:<span style="color:#666">
</span><span style="color:#666">    </span>- ROCKETCHAT_URL=<span style="color:#3677a9">192.168.0.26</span>:<span style="color:#3677a9">3000</span><span style="color:#666">
</span><span style="color:#666">    </span>- ROCKETCHAT_ROOM=GENERAL<span style="color:#666">
</span><span style="color:#666">    </span>- ROCKETCHAT_USER=Botname<span style="color:#666">
</span><span style="color:#666">    </span>- ROCKETCHAT_PASSWORD=BotPassw0rd<span style="color:#666">
</span><span style="color:#666">    </span>- BOT_NAME=Botname<span style="color:#666">
</span><span style="color:#666">    </span>- EXTERNAL_SCRIPTS=hubot-help,hubot-seen,hubot-links,hubot-greetings<span style="color:#666">
</span><span style="color:#666">  </span><span style="color:#6ab825;font-weight:bold">links</span>:<span style="color:#666">
</span><span style="color:#666">    </span>- rocketchat:rocketchat<span style="color:#666">
</span><span style="color:#666"></span><span style="color:#999;font-style:italic">#Esto se utiliza para exponer el puerto de hubot para las notificaciones del host en el puerto 3001 para hubot-jenkins-notifier</span><span style="color:#666">
</span><span style="color:#666">  </span><span style="color:#6ab825;font-weight:bold">ports</span>:<span style="color:#666">
</span><span style="color:#666">    </span>- <span style="color:#3677a9">3001</span>:<span style="color:#3677a9">8080</span><span style="color:#666">
</span></code></pre></div><p>Editar los siguientes parámetros:</p>
<p><strong>ROOT_URL:</strong> El FQDN de nuestro host en este caso usare el dominio <strong>chat.braybaut.com // <em>En mi caso no voy a exponer el chat a internet, por el cual, este dominio es interno.</em></strong></p>
<p><strong>ROCKETCHAT_URL:</strong> Debemos usar la IP de nuestro host donde van a correr los contenedores que componen rocket.chat</p>
<p><strong>ROCKETCHAT_USER, ROCKETCHAT_PASSWORD y BOT_NAME:</strong> son valores que ya van a criterio de ustedes</p>
<h3 id="reglas-de-firewall">Reglas de Firewall</h3>
<p>Ya para terminar, aplicamos una regla de firewall para abrir el puerto 3000 el cual es el que utilizamos para acceder a rocket.chat</p>
<pre><code class="language-console" data-lang="console">firewall-cmd --add-port=3000/tcp --permanent
</code></pre><h3 id="descargando-imágenes-y-desplegando-contenedores">Descargando imágenes y desplegando contenedores</h3>
<p>Por ultimo, vamos a correr el archivo docker-compose.yml, en este archivo el bajara los 3 docker image necesarios y posteriormente iniciara un contenedor para cada uno, los docker image que se descargaran son: <strong>mongodb, rocket.chat (ultima versión) y hubot.</strong></p>
<p>Despues de bajar las imágenes docker-compose creara los contenedores y aplicara las configuraciones que se encuentran en el archivo docker-compose.yml.</p>
<p>Ingresamos al directorio:</p>
<pre><code class="language-console" data-lang="console">cd /opt/rocket.chat/
</code></pre><p>Ejecutamos Docker compose:</p>
<pre><code class="language-console" data-lang="console">docker-compose up
</code></pre><p>La primera vez que se ejecute docker-compose se demorara un poco, debido a que debe descargar los docker image, cuando se vuelva a ejecutar docker-compose la ejecución de los contenedores sera breve debido a que los docker image ya existen.</p>
<p>Después de ejecutar el comando anterior y nos aparezca la siguiente imagen quiere decir que el proceso de despliegue y ejecución a terminado y podemos acceder a nuestro rocket.chat.</p>
<p><img src="/images/rocketchat3.png" alt=""></p>
<p>Verificamos que los contenedores estén corriendo:</p>
<pre><code class="language-code" data-lang="code">docker ps -a
</code></pre><p><img src="/images/rocketchat4.png" alt=""></p>
<p>Ingresamos al navegador para ingresar al chat:</p>
<p><img src="/images/rocketchat5.png" alt=""></p>
<p>Con esto ya terminamos y comprobamos que nuestro Rocket.chat esta corriendo sin ningún inconveniente y lo mejor, en contenedores con persistencia de data.</p>
<p>Próximamente escribiré un articulo el cual explicare como subir estos contenedores usando <strong>systemctl.</strong></p>
<p>Mas información:</p>
<p>[<strong>https://rocket.chat/</strong>]</p>
<p>[<strong>https://github.com/RocketChat/Rocket.Chat</strong>]</p>
<p>[<strong>https://hub.docker.com/u/rocketchat/</strong>]</p>]]></content>
        </item>
        
        <item>
            <title>Autentificación LDAP Vtiger CRM 6</title>
            <link>/posts/autentificaci%C3%B3n-ldap-vtiger-crm-6/</link>
            <pubDate>Tue, 19 Jan 2016 01:43:11 +0000</pubDate>
            
            <guid>/posts/autentificaci%C3%B3n-ldap-vtiger-crm-6/</guid>
            <description>&lt;p&gt;&lt;img src=&#34;/images/vtiger1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Vtiger es un CRM de código abierto muy potente que trata de acercarse  a grandes crms como salesforce y SugarCRM, pero en esta ocasión veremos como autentificarlo hacia LDAP.&lt;/p&gt;
&lt;p&gt;Con un gran compañero de la compañía &lt;a href=&#34;https://twitter.com/Gabo_fdc?s=09&#34;&gt;Gabo&lt;/a&gt;, logramos hacer la autentificación continuación describo los pasos para lograrla.&lt;/p&gt;
&lt;p&gt;Para lograr la autentificación debemos usar los archivos de autentificación de Vtiger de 5.x,  estos archivos los encuentran en github.&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;a href=&#34;https://github.com/braybaut/ldap-vtiger&#34;&gt;https://github.com/braybaut/ldap-vtiger&lt;/a&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p><img src="/images/vtiger1.jpg" alt=""></p>
<p>Vtiger es un CRM de código abierto muy potente que trata de acercarse  a grandes crms como salesforce y SugarCRM, pero en esta ocasión veremos como autentificarlo hacia LDAP.</p>
<p>Con un gran compañero de la compañía <a href="https://twitter.com/Gabo_fdc?s=09">Gabo</a>, logramos hacer la autentificación continuación describo los pasos para lograrla.</p>
<p>Para lograr la autentificación debemos usar los archivos de autentificación de Vtiger de 5.x,  estos archivos los encuentran en github.</p>
<p><!-- raw HTML omitted --><a href="https://github.com/braybaut/ldap-vtiger">https://github.com/braybaut/ldap-vtiger</a><!-- raw HTML omitted --></p>
<p>Los archivos Ldap.php y config.ldap.php deben quedar en la siguiente ruta:</p>
<pre><code class="language-code" data-lang="code">/var/www/html/vtigercrm/include/ldap/
</code></pre><p><strong>Nota: debe editar el archivo Config.ldap.php y adicionar la configuración de su servidor LDAP</strong></p>
<p><em>la ruta puede variar dependiendo de donde tenga ubicado los archivos de  vtiger.</em></p>
<p>A continuación debemos hacer unos cambios en el archivo:</p>
<pre><code class="language-code" data-lang="code">/var/www/html/vtigercrm/modules/Users/Users.php
</code></pre><p>Este archivo es el encargado de hacer la autentificación de los usuarios, aquí lo que vamos  hacer es llamar  los archivos <strong>Ldap.php y Config.ldap.php</strong> para que lea las variables y posteriormente lograr la autentificación, igualmente haremos un cambio en una función para que no se presenten problemas.</p>
<p>Adicionar las siguientes dos lineas al final de los require once , aproximadamente en la linea 41:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php">require_once &#39;include/ldap/config.ldap.php&#39;;
require_once &#39;include/ldap/ldap.php&#39;;
</code></pre></div><p>La función dologin la cual es:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php">function doLogin($user_password) {
        global $AUTHCFG;
        $usr_name = $this-&amp;gt;column_fields[&#34;user_name&#34;];

        switch (strtoupper($AUTHCFG[&#39;authType&#39;])) {
            case &#39;LDAP&#39;:
                $this-&amp;gt;log-&amp;gt;debug(&#34;Using LDAP authentication&#34;);
                require_once(&#39;modules/Users/authTypes/LDAP.php&#39;);
                $result = ldapAuthenticate($this-&amp;gt;column_fields[&#34;user_name&#34;], $user_password);
                if ($result == NULL) {
                    return false;
                } else {
                    return true;
                }
                break;

</code></pre></div><p>Debe ser cambiada por esta:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-php" data-lang="php">function doLogin($user_password) {
        global $AUTHCFG;
        $usr_name = $this-&amp;gt;column_fields[&#34;user_name&#34;];

        // Allow the &#39;admin&#39; always to log in independent from the LDAP server
        $usr_list = $AUTHCFG[&#39;sql_accounts&#39;];

        if (in_array(strtolower($usr_name), $usr_list))
            $AUTHCFG[&#39;authType&#39;] = &#39;SQL&#39;;

        //SEAN TSANG PATCH START - User must exists in database first
        $query = &#34;SELECT * from $this-&amp;gt;table_name where user_name=?&#34;;
               $result = $this-&amp;gt;db-&amp;gt;requirePsSingleResult($query, array($usr_name), false);
              if (empty($result)) return false;
        //SEAN TSANG PATCH END------------------------------------------

        switch (strtoupper($AUTHCFG[&#39;authType&#39;])) {
            case &#39;LDAP&#39;:
                $this-&amp;gt;log-&amp;gt;debug(&#34;Using LDAP authentication&#34;);
                require_once(&#39;include/ldap/Ldap.php&#39;);
                return ldapAuthenticate($this-&amp;gt;column_fields[&#34;user_name&#34;], $user_password);

</code></pre></div><p>Después de estos cambios la autentificación desde LDAP debe funcionar.</p>
<p>Importante:</p>
<p>Automáticamente el no autentificara con los usuarios que esten el el servidor LDAP, Para que funcione debe crear los usuarios en vtiger con  usuario, contraseña, correo electrónico, etc  <strong>(NO IMPORTA LA CONTRASEÑA QUE ASIGNE AL CREAR LA CUENTA,  AL AUTENTIFICARSE CON UN USUARIO, VTIGER BUSCARA LA CONTRASEÑA EN EL SERVIDOR LDAP Y NO USARA LA QUE USTED ASIGNO, EL USERNAME DEL USUARIO DE VTIGER DEBE SER EL MISMO USERNAME DEL USUARIO EN LDAP)</strong></p>
<p>PD: Funciona para todas las versiones de 6.X tanto para 6.0 como para 6.4</p>]]></content>
        </item>
        
        <item>
            <title>Howto: como crear un contenedor de datos en docker</title>
            <link>/posts/howto-como-crear-un-contenedor-de-datos-en-docker/</link>
            <pubDate>Wed, 13 Jan 2016 17:40:11 +0000</pubDate>
            
            <guid>/posts/howto-como-crear-un-contenedor-de-datos-en-docker/</guid>
            <description>&lt;p&gt;&lt;img src=&#34;/images/docker.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;los contenedores no son persistentes en sus datos al ser ejecutados, esto quiere decir que al terminar una ejecución de un contenedor este pierde sus datos.&lt;/p&gt;
&lt;p&gt;Existen varias practicas para realizar la persistencia de los datos, en esta ocasión usaremos un contenedor de datos ( data container) para hacer la persistencia.&lt;/p&gt;
&lt;p&gt;Este contenedor solo guardara la información que se requiere sea persistente, no es necesario que este iniciado ya que  lo podemos compartir sin necesidad  de que este ejecutado.&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p><img src="/images/docker.png" alt=""></p>
<p>los contenedores no son persistentes en sus datos al ser ejecutados, esto quiere decir que al terminar una ejecución de un contenedor este pierde sus datos.</p>
<p>Existen varias practicas para realizar la persistencia de los datos, en esta ocasión usaremos un contenedor de datos ( data container) para hacer la persistencia.</p>
<p>Este contenedor solo guardara la información que se requiere sea persistente, no es necesario que este iniciado ya que  lo podemos compartir sin necesidad  de que este ejecutado.</p>
<p>Un ejemplo para crear un contenedor que guardara los datos de la ruta</p>
<p>**/var/www/html/ ** para un servidor web con apache:</p>
<pre><code class="language-code" data-lang="code">Creando un contenedor de datos&quot;&gt;docker run -v /var/www/html --name data-apache httpd true
</code></pre><p>Podemos usar <strong>docker ps -a</strong> para observar  si el contenedor fue creado.</p>
<p>Ahora para poner usar el contenedor de datos lo que hacemos es crear un nuevo contenedor usando como volumen el contenedor <strong>“data-apache”</strong></p>
<pre><code class="language-code" data-lang="code">docker run -dt --name apache --volumes-from data-apache --restart=always  httpd
</code></pre><p>Con el comando anterior iniciamos un contenedor usando los volumenes del contenedor <strong>“data-apache”</strong> de esta manera así borremos el contenedor <strong>“apache”</strong> los datos se conservaran  y solo tenemos que iniciar otro contenedor indicando el contenedor de datos.</p>
<p>Mas información <a href="https://docs.docker.com/engine/userguide/dockervolumes/">aqui</a>.</p>]]></content>
        </item>
        
        <item>
            <title>Docker: Ingresar al bash de un contenedor iniciado | Script</title>
            <link>/posts/docker-ingresar-al-bash-de-un-contenedor-iniciado-script/</link>
            <pubDate>Tue, 12 Jan 2016 04:40:50 +0000</pubDate>
            
            <guid>/posts/docker-ingresar-al-bash-de-un-contenedor-iniciado-script/</guid>
            <description>&lt;p&gt;&lt;img src=&#34;/images/docker.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Ultimamente he trabajado mucho con docker y en el maravilloso recorrido que he tenido con docker se me presento un problema gigante,  inicio el contenedor con su servicio pero por X o Y motivo quiero ingresar al bash y el “docker attach” no funciona porque el docker no lo inicie con /bin/bash&lt;/p&gt;
&lt;p&gt;Una solución es abrir el puerto 22 e ingresar por ssh, pero no es la gracia trabajar de esta manera ya que estamos con container. Navegando por la red encontré un comando un poco largo para poder ingresar al bash del container y un compañero de la compañía donde trabajo también me paso uno parecido, pero me pareció algo fastidioso usar un comando largo para ingresar al bash entonces me tome la tarea de crear un script para que me facilite esta tarea, se los mostrare:&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p><img src="/images/docker.png" alt=""></p>
<p>Ultimamente he trabajado mucho con docker y en el maravilloso recorrido que he tenido con docker se me presento un problema gigante,  inicio el contenedor con su servicio pero por X o Y motivo quiero ingresar al bash y el “docker attach” no funciona porque el docker no lo inicie con /bin/bash</p>
<p>Una solución es abrir el puerto 22 e ingresar por ssh, pero no es la gracia trabajar de esta manera ya que estamos con container. Navegando por la red encontré un comando un poco largo para poder ingresar al bash del container y un compañero de la compañía donde trabajo también me paso uno parecido, pero me pareció algo fastidioso usar un comando largo para ingresar al bash entonces me tome la tarea de crear un script para que me facilite esta tarea, se los mostrare:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">clear

<span style="color:#999;font-style:italic">##Show container and Id</span> 
<span style="color:#24909d">echo</span> <span style="color:#ed9d13">&#34;runing container&#34;</span>
<span style="color:#24909d">echo</span> 

docker ps -a | grep Up |  awk <span style="color:#ed9d13">&#39; { print $1,&#34;   &#34; $NF}&#39;</span>



<span style="color:#24909d">echo</span> 
<span style="color:#24909d">echo</span> 
<span style="color:#999;font-style:italic">## Insert Id or name of container</span>  

<span style="color:#24909d">echo</span> <span style="color:#ed9d13">&#34;Insert id or name of Container to login bash&#34;</span>
<span style="color:#24909d">read</span> CONTAINER

<span style="color:#999;font-style:italic">##LOGIN TO CONTAINER</span> 

<span style="color:#40ffff">ct</span>=<span style="color:#40ffff">$CONTAINER</span> &amp;&amp; sudo nsenter --target <span style="color:#6ab825;font-weight:bold">$(</span>docker inspect --format {{.State.Pid}} <span style="color:#40ffff">$ct</span><span style="color:#6ab825;font-weight:bold">)</span> --moun --uts --ipc --net --pid

</code></pre></div><p>El proyecto se encuentra en github, le hare algunas mejoras para que sea aun mas automatizado, pero sera mas adelante.</p>
<p><!-- raw HTML omitted --><a href="https://github.com/braybaut/LoginDocker">https://github.com/braybaut/LoginDocker</a><!-- raw HTML omitted --></p>
<p>Al correr el script este les mostrara el Id y el nombre de los contenedores que estan corriendo, despues deben escribir el id o el nombre del contenedor al cual quieren ingresar al bash</p>
<p>Ejemplo:</p>
<p><img src="/images/docker1.png" alt=""></p>
<p>Lo ideal es dejar el script en <strong>/usr/local/bin/</strong> para que podamos llamarlo desde cualquier ubicación en nuestra consola.</p>
<p>Eso es todo algo sencillo que realmente nos facilitara la vida.</p>]]></content>
        </item>
        
        <item>
            <title>Introducción Vpn Full Mesh con Tinc y configuración en Raspberry Pi</title>
            <link>/posts/introducci%C3%B3n-vpn-full-mesh-con-tinc-y-configuraci%C3%B3n-en-raspberry-pi/</link>
            <pubDate>Mon, 24 Mar 2014 06:18:00 +0000</pubDate>
            
            <guid>/posts/introducci%C3%B3n-vpn-full-mesh-con-tinc-y-configuraci%C3%B3n-en-raspberry-pi/</guid>
            <description>&amp;lt;div class=&amp;quot;separator&amp;quot; style=&amp;quot;clear:both;text-align:center;&amp;quot;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;separator&amp;quot; style=&amp;quot;clear:both;text-align:center;&amp;quot;&amp;gt; &amp;lt;a href=&amp;quot;https://braybaut.files.wordpress.com/2014/03/8000d-tinclogo1.png?w=648&amp;quot; style=&amp;quot;margin-left:1em;margin-right:1em;&amp;quot;&amp;gt;&amp;lt;img border=&amp;quot;0&amp;quot; src=&amp;quot;https://braybaut.files.wordpress.com/2014/03/8000d-tinclogo1.png?w=648&amp;quot; data-recalc-dims=&amp;quot;1&amp;quot; /&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; Con tinc Podemos crear una &amp;lt;b&amp;gt;VPN &amp;lt;/b&amp;gt;tipo full mesh(&amp;lt;i&amp;gt;Nodos conectados entre s&amp;lt;/i&amp;gt;i), Estableciendo la comunicación de todos los host conectados a cada nodo. Cabe aclarar que cada nodo es el servidor donde esta configurado tinc. &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; Tinc esta lanzada bajo licencia GPL que en pocas palabras podemos decir que es &amp;lt;b&amp;gt;Software Libre =D&amp;lt;/b&amp;gt;, este maravilloso protocolo nos ofrece unas caracteristicas que son: &amp;lt;/p&amp;gt; &amp;lt;ul style=&amp;quot;text-align:left;&amp;quot;&amp;gt; &amp;lt;li&amp;gt; Encryptation, Authenticatión and compressión: Comprime los paquetes antes de enviarlos, encripta los datos para que uestra información viaje segura en este medio tan inseguro como lo es la internet, ofrece la autentificación para que los nodos desconocidos no se puedan conectar a nuestra red.</description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<pre><code>            &lt;div class=&quot;separator&quot; style=&quot;clear:both;text-align:center;&quot;&gt;
            &lt;/div&gt;
            
            &lt;div class=&quot;separator&quot; style=&quot;clear:both;text-align:center;&quot;&gt;
              &lt;a href=&quot;https://braybaut.files.wordpress.com/2014/03/8000d-tinclogo1.png?w=648&quot; style=&quot;margin-left:1em;margin-right:1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://braybaut.files.wordpress.com/2014/03/8000d-tinclogo1.png?w=648&quot; data-recalc-dims=&quot;1&quot; /&gt;&lt;/a&gt;
            &lt;/div&gt;
            
            &lt;p&gt;
              Con tinc Podemos crear una &lt;b&gt;VPN &lt;/b&gt;tipo full mesh(&lt;i&gt;Nodos conectados entre s&lt;/i&gt;i),  Estableciendo la comunicación de todos los host conectados a cada nodo. Cabe aclarar que cada nodo es el servidor donde esta configurado tinc.
            &lt;/p&gt;
            
            &lt;p&gt;
              Tinc esta lanzada bajo licencia GPL que en pocas palabras podemos decir que es &lt;b&gt;Software Libre =D&lt;/b&gt;, este maravilloso protocolo nos ofrece unas caracteristicas que son:
            &lt;/p&gt;
            
            &lt;ul style=&quot;text-align:left;&quot;&gt;
              &lt;li&gt;
                Encryptation, Authenticatión and compressión: Comprime los paquetes antes de enviarlos, encripta los datos para que uestra información viaje segura en este medio tan inseguro como lo es la internet, ofrece la autentificación para que los nodos desconocidos no se puedan conectar a nuestra red.&lt;a name='more'&gt;&lt;/a&gt;
              &lt;/li&gt;
              &lt;li&gt;
                Automatic Full Mesh routing: Sin importar la configuración del demonio, tinc siempre buscara la mejor ruta entre la mesh para no tener que dar saltos o si este es necesario, lograr de que los saltos sean menores.
              &lt;/li&gt;
            &lt;/ul&gt;
            
            &lt;ul style=&quot;text-align:left;&quot;&gt;
              &lt;li&gt;
                 Easily expand your VPN: tinc se destaca por su facil configuración para que otro nodo ingrese a la mesh, solo se tiene que configurar dos nodos, el primero el nodo que va a ingresar a la mesh y el otro nodo el que ya esta en la mesh conectados con los otros. Ya cuando estos dos nodos esten conectados, el nodo nuevo podra ver a todos los nodos conectados. Es recomendable hacer las conexiones con mas de un nodo ya que si se pierda la conexión con un nodo, este ira por otra conexión o en pocas palabras otra ruta.
              &lt;/li&gt;
            &lt;/ul&gt;
            
            &lt;p&gt;
              Existen diferentes topologias que podemos usar para establecer la conexión entre los nodos, ya es cuestión de comodidad en conexiones y uso de cada usuario.
            &lt;/p&gt;
            
            &lt;div class=&quot;separator&quot; style=&quot;clear:both;text-align:center;&quot;&gt;
              &lt;a href=&quot;https://braybaut.files.wordpress.com/2014/03/4fc7b-redes-topologia.png?resize=320%2C187&quot; style=&quot;margin-left:1em;margin-right:1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://braybaut.files.wordpress.com/2014/03/4fc7b-redes-topologia.png?resize=320%2C187&quot; height=&quot;187&quot; width=&quot;320&quot; data-recalc-dims=&quot;1&quot; /&gt;&lt;/a&gt;
            &lt;/div&gt;
            
            &lt;p&gt;
            &lt;/p&gt;
            
            &lt;ul style=&quot;text-align:left;&quot;&gt;
            &lt;/ul&gt;
            
            &lt;p&gt;
              Tenemos que redireccionar en nuestro router el puerto 655 (TCP y UDP) hacia nuestro raspberry donde estara tinc
            &lt;/p&gt;
            
            &lt;p&gt;
              Ahora vamos al grano, para instalar tinc en nuestro raspberry Pi, los pasos son sencillos, !Iniciemos!
            &lt;/p&gt;
            
            &lt;p&gt;
              Antes de instalar tinc, procedemos a activar tun, para poder gestionar la interfaz virtual
            &lt;/p&gt;
            
            &lt;blockquote&gt;
              &lt;p&gt;
                &lt;code&gt;modprobe tun &lt;/code&gt;
              &lt;/p&gt;
            &lt;/blockquote&gt;
            
            &lt;p&gt;
              Ahora si:
            &lt;/p&gt;
            
            &lt;p&gt;
              &lt;b&gt;Rasbian&lt;/b&gt;
            &lt;/p&gt;
            
            &lt;blockquote&gt;
              &lt;p&gt;
                &lt;code&gt;sudo apt-get install tinc &lt;/code&gt;
              &lt;/p&gt;
            &lt;/blockquote&gt;
            
            &lt;p&gt;
              &lt;b&gt;Archlinux arm&lt;/b&gt;
            &lt;/p&gt;
            
            &lt;blockquote&gt;
              &lt;p&gt;
                &lt;code&gt;sudo pacman -S tinc&lt;/code&gt;
              &lt;/p&gt;
            &lt;/blockquote&gt;
            
            &lt;h3 style=&quot;text-align:left;&quot;&gt;
              Configuración
            &lt;/h3&gt;
            
            &lt;h3 style=&quot;text-align:left;&quot;&gt;
               
            &lt;/h3&gt;
            
            &lt;div style=&quot;text-align:left;&quot;&gt;
              Creamos los directorios de configuración:
            &lt;/div&gt;
            
            &lt;blockquote&gt;
              &lt;p&gt;
                &lt;code&gt;sudo mkdir /etc/tinc/vpnraspberry&amp;lt;br /&gt;sudo mkdir /etc/tinc/vpnraspberry/hosts&lt;/code&gt;
              &lt;/p&gt;
            &lt;/blockquote&gt;
            
            &lt;div style=&quot;text-align:left;&quot;&gt;
              Creamos el archivo /etc/tinc/vpnraspberry/tinc.conf:&lt;/p&gt; 
              
              &lt;blockquote&gt;
                &lt;p&gt;
                  &lt;code&gt;Name = raspberry&amp;lt;br /&gt;Device = /dev/net/tun&lt;/code&gt; &lt;&lt;br /&gt;&lt;code&gt;PrivateKeyFile = /etc/tinc/vpnraspberrypi/rsa_key.priv&lt;/code&gt;&lt;br /&gt;&lt;code&gt;Interface = rp0 ##Nombre de la interfaz, cada quien es libre de darle un nombre&lt;/code&gt;
                &lt;/p&gt;
              &lt;/blockquote&gt;
              
              &lt;p&gt;
                Creamos el archivo /etc/tinc/vpnraspberry/host/raspberry:
              &lt;/p&gt;
              
              &lt;blockquote&gt;
                &lt;p&gt;
                  &lt;code&gt;&amp;lt;br /&gt;Subnet = 10.0.0.1/32&amp;lt;br /&gt;Address = 1.2.3.4 ## en esta linea ira la ip publica.&lt;/code&gt;
                &lt;/p&gt;
              &lt;/blockquote&gt;
              
              &lt;p&gt;
              &lt;/p&gt;
              
              &lt;div style=&quot;text-align:left;&quot;&gt;
                Generamos las llaves para el nodo:
              &lt;/div&gt;
              
              &lt;div style=&quot;text-align:left;&quot;&gt;
                  
              &lt;/div&gt;
              
              &lt;div style=&quot;text-align:left;&quot;&gt;
                &lt;blockquote&gt;
                  &lt;p&gt;
                    &lt;code&gt;sudo tincd -n vpnraspberry -K&lt;/code&gt; &lt;code&gt; &lt;/code&gt;&lt;br /&gt;&lt;code&gt;Generating 1024 bits keys:&amp;lt;br /&gt;..............++++++ p&amp;lt;br /&gt;..............++++++ q&amp;lt;br /&gt;Done.&amp;lt;br /&gt;Please enter a file to save private RSA key to [/etc/tinc/vpnraspberry/rsa_key.priv]:&amp;lt;br /&gt;Please enter a file to save public RSA key to [/etc/tinc/raspberry/hosts/raspberry]:&amp;lt;br /&gt;Appending key to existing contents.&amp;lt;br /&gt;Make sure only one key is stored in the file.&lt;/code&gt;
                  &lt;/p&gt;
                &lt;/blockquote&gt;
                
                &lt;p&gt;
                  Configuramos la interfaz rp0, en este caso crearemos un script en &amp;#8220;/etc/tinc/vpnraspberry/tinc-up&amp;#8221;, que usara Tinc para arrancar la interfaz
                &lt;/p&gt;
                
                &lt;blockquote&gt;
                  &lt;p&gt;
                    &lt;code&gt;#!/bin/sh&amp;lt;br /&gt;ifconfig rp0 10.0.0.1 netmask 255.255.0.0&lt;/code&gt;
                  &lt;/p&gt;
                &lt;/blockquote&gt;
                
                &lt;p&gt;
                  Damos permisos de ejecución
                &lt;/p&gt;
                
                &lt;p&gt;
                   
                &lt;/p&gt;
                
                &lt;blockquote&gt;
                  &lt;p&gt;
                    &lt;code&gt;# chmod +x /etc/tinc/tinc-up&lt;/code&gt;
                  &lt;/p&gt;
                &lt;/blockquote&gt;
                
                &lt;p&gt;
                  Por ultimo,, creamos un script, que dará de baja la interfaz usada cuando Tinc no este activo, Al igual como el script anterior, le damos permisos de ejecución
                &lt;/p&gt;
                
                &lt;blockquote&gt;
                  &lt;p&gt;
                    &lt;code&gt;#!/bin/sh&lt;/code&gt;&lt;br /&gt;&lt;code&gt;ifconfig rp0 down&lt;/code&gt;
                  &lt;/p&gt;
                &lt;/blockquote&gt;
                
                &lt;p&gt;
                  !!Listo!!&lt;span class=&quot;fullpost&quot;&gt;  La configuración de tinc en nuestra raspberry ya esta terminada, ahora para arrancar tinc escribimos en nuestra consola&lt;/span&gt;
                &lt;/p&gt;
                
                &lt;blockquote&gt;
                  &lt;p&gt;
                    &lt;code&gt;sudo tincd -D -d -n vpnraspberry &lt;/code&gt;
                  &lt;/p&gt;
                &lt;/blockquote&gt;
                
                &lt;p&gt;
                  &lt;span class=&quot;fullpost&quot;&gt;&lt;/span&gt;
                &lt;/p&gt;
                
                &lt;div style=&quot;text-align:left;&quot;&gt;
                  &lt;span class=&quot;fullpost&quot;&gt;&lt;br /&gt;&lt;!-- AddThis Button BEGIN --&gt;&lt;/span&gt;
                &lt;/div&gt;
                
                &lt;p&gt;
                  &lt;span class=&quot;fullpost&quot;&gt;Si todo esta a la perfección tinc nos mostrara :&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;fullpost&quot;&gt;&lt;br /&gt;&lt;!-- AddThis Button BEGIN --&gt;&lt;/span&gt;
                &lt;/p&gt;
                
                &lt;div class=&quot;separator&quot; style=&quot;clear:both;text-align:center;&quot;&gt;
                  &lt;a href=&quot;https://braybaut.files.wordpress.com/2014/03/16b3c-tincd.png?resize=320%2C61&quot; style=&quot;margin-left:1em;margin-right:1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://braybaut.files.wordpress.com/2014/03/16b3c-tincd.png?resize=320%2C61&quot; height=&quot;61&quot; width=&quot;320&quot; data-recalc-dims=&quot;1&quot; /&gt;&lt;/a&gt;
                &lt;/div&gt;
                
                &lt;p&gt;
                  &lt;span class=&quot;fullpost&quot;&gt;Para que otros nodos tinc  se conecten a nuestro nodo tenemos que compartirle nuestro archivo raspberry alojado en &lt;i&gt;/etc/tinc/vpnraspberry/hosts/ &lt;/i&gt;y alojarlo en el directorio hosts de dicho nodo, este Archivo contiene la llave generada anteriormente, adicionalmente ese nodo debe ingresar en el tinc.conf la linea &lt;i&gt;connectTo = raspberry&lt;/i&gt;, esa linea especifica que se conectada al nodo raspberry. Para permitir la conexión de ese nodo, debemos tener en nuestro directorio hosts, El archivo donde se encuentra la llave del nodo que desea conectarse con nuestro nodo.&lt;/p&gt; 
                  
                  &lt;p&gt;
                    Mas adelante explicare como lograr que otros nodos se conecten a la raspberry logrando la creación de una mesh, también hablare un poco sobre la unión de tinc, con openvpn, pptd y otras herramientas.&lt;/span&gt;
                  &lt;/p&gt;
                  
                  &lt;p&gt;
                    &lt;span class=&quot;fullpost&quot;&gt;Proyecto Tinc:&lt;a href=&quot;http://www.tinc-vpn.org/&quot; target=&quot;_blank&quot;&gt; http://www.tinc-vpn.org/ &lt;/a&gt;&lt;/span&gt;
                  &lt;/p&gt;
                  
                  &lt;div class=&quot;addthis_toolbox addthis_default_style &quot;&gt;
                    &lt;span class=&quot;fullpost&quot;&gt;&lt;a class=&quot;addthis_button_facebook_like&quot; href=&quot;https://www.blogger.com/null&quot;&gt;&lt;/a&gt;&lt;a class=&quot;addthis_button_tweet&quot; href=&quot;https://www.blogger.com/null&quot;&gt;&lt;/a&gt;&lt;a class=&quot;addthis_counter addthis_pill_style&quot; href=&quot;https://www.blogger.com/null&quot;&gt;&lt;/a&gt;&lt;/span&gt;
                  &lt;/div&gt;
                  
                  &lt;p&gt;
                    &lt;span class=&quot;fullpost&quot;&gt;&lt;a href=&quot;http://s7.addthis.com/js/250/addthis_widget.js#pubid=xa-4dcde18b394a19ad&quot;&gt;http://s7.addthis.com/js/250/addthis_widget.js#pubid=xa-4dcde18b394a19ad&lt;/a&gt;&lt;!-- AddThis Button END --&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;
</code></pre>
]]></content>
        </item>
        
    </channel>
</rss>
