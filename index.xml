<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Braybaut</title>
    <link>/</link>
    <description>Recent content on Braybaut</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 06 Aug 2020 12:51:50 -0500</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Integrate Terraform Language Server Protocol With vim</title>
      <link>/posts/integrate-terraform-language-server-protocol-with-vim/</link>
      <pubDate>Thu, 06 Aug 2020 12:51:50 -0500</pubDate>
      
      <guid>/posts/integrate-terraform-language-server-protocol-with-vim/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;/images/vim.png&#34; alt=&#34;VIM&#34;&gt;&lt;/p&gt;
&lt;p&gt;We write large-scale infrastructure with terraform. We spend hours creating modules, writing resources, developing infrastructure. To feel more comfortable, surely we need a langserver in our editor. I&amp;rsquo;ll show how to integrate a terraform langserver in vim - making it a Swiss Army Knife.&lt;/p&gt;
&lt;p&gt;The Language Server protocol is used between a tool (the client) and a language smartness provider (the server) to integrate features. Like auto complete, go to definition, find all references and alike into the tool. This post explains how to integrate &lt;strong&gt;terraform-lsp&lt;/strong&gt; on vim.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Continuous Integration for Golang Applications with Terraform, Codebuilds and ECR</title>
      <link>/posts/continuous-integration-for-golang-applications-with-terraform-codebuilds-and-ecr/</link>
      <pubDate>Fri, 26 Jul 2019 16:58:24 -0500</pubDate>
      
      <guid>/posts/continuous-integration-for-golang-applications-with-terraform-codebuilds-and-ecr/</guid>
      <description>I wrote this post for sharing, how we can do continuous integration for Golang APIs with some tools. In this post I&amp;rsquo;m going to use terraform for making a codebuild resource, Code build to build the Golang API and generate a docker image and ECR for keeping the docker image.
The workflow: The continuous integration workflow is very easy to understand, every time a new tag is created the webhook will start the job, Codebuild will compile the Golang API and will generate the docker image, then will run a docker push to AWS ECR,</description>
    </item>
    
    <item>
      <title>Construyendo Un cluster de Kubernetes en AWS EKS Con Terraform</title>
      <link>/posts/construyendo-un-cluster-de-kubernetes-en-aws-eks-con-terraform/</link>
      <pubDate>Fri, 05 Apr 2019 09:03:17 -0500</pubDate>
      
      <guid>/posts/construyendo-un-cluster-de-kubernetes-en-aws-eks-con-terraform/</guid>
      <description>Kubernetes sin duda es uno de los mejores containers orquestation que tenemos en el mercado y hoy en dia, muchos vendors ofrecen Kubernetes como servicio, AWS no se ha quedado atras y en junio del año pasado, anuncio Elastic Kubernetes Services.
El cluster que desplegaremos, se compone de los siguientes resources:</description>
    </item>
    
    <item>
      <title>Posts</title>
      <link>/archive/</link>
      <pubDate>Sun, 24 Mar 2019 17:12:48 -0500</pubDate>
      
      <guid>/archive/</guid>
      <description></description>
    </item>
    
    <item>
      <title>About me</title>
      <link>/about/</link>
      <pubDate>Sun, 24 Mar 2019 16:46:05 -0500</pubDate>
      
      <guid>/about/</guid>
      <description>My name is Brayan Bautista and I am living in Bogotá Colombia. I’m a System Engineering and am working as a Cloud and DevOps Engineer at Globant where I help customers to desing architectures to make scalables infrastructures and creating workflows to deploy in production environments with zero downtime.
I’m also Container and OpenSource Enthusiast, I really enjoy writing about anything that might help other engineers out with topics i can see in my daily basis, I’m interested in anything about containers, serverless and distributed systems, I really enjoy learning new languages and tools that can help in my career path, I also enjoy participate as a speaker at local meetups that promote the OpenSource.</description>
    </item>
    
    <item>
      <title>Parseando JSON con Golang y las naves de spaceX</title>
      <link>/posts/parseando-json-con-golang-y-las-naves-de-spacex/</link>
      <pubDate>Sun, 10 Feb 2019 21:52:53 +0000</pubDate>
      
      <guid>/posts/parseando-json-con-golang-y-las-naves-de-spacex/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;/images/maxresdefault.jpg&#34; alt=&#34;Golang&#34;&gt;&lt;/p&gt;
&lt;p&gt;Golang se ha convertido en uno de mis lenguajes favoritos y hoy escribiré de como podemos usar go para poder consumir la API de spaceX y obtener información de las naves lanzadas al espacio&lt;/p&gt;
&lt;p&gt;Soy admirador total de &lt;a href=&#34;https://en.wikipedia.org/wiki/Elon_Musk&#34;&gt;Elon musk&lt;/a&gt; y de todas sus compañías, una de ellas es &lt;a href=&#34;https://www.spacex.com/&#34;&gt;spaceX&lt;/a&gt;, una compañía dedicada al transporte aeroespacial y hoy por medio de Golang vamos a obtener información de su ultima nave lanzada al espacio.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Creando un cluster de kubernetes en GCP con terraform</title>
      <link>/posts/creando-un-cluster-de-kubernetes-en-gcp-con-terraform/</link>
      <pubDate>Sun, 03 Feb 2019 21:44:10 +0000</pubDate>
      
      <guid>/posts/creando-un-cluster-de-kubernetes-en-gcp-con-terraform/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;/images/terra-gcp-kubernetes2.png&#34; alt=&#34;Kubernetes&#34;&gt;&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;Terraform, es una de las herramientas mas potentes de hashicorp y hoy en día es usada por grandes compañías para mantener infraestructura en la nube.&lt;/p&gt;
&lt;p&gt;Terraform destaca porque podemos trabajar con múltiples providers al mismo tiempo, ¿ que quiere decir esto ? que le podemos decir a terraform que cuando se cree una nueva instancia en GCP al mismo tiempo  genere un registro DNS en route53 en AWS, esto de una manera muy sencilla.&lt;/p&gt;
&lt;p&gt;Pero hoy no vamos a hablar de AWS, hoy vamos a hablar de GCP, una nube muy poderosa que tiene características muy interesantes para tener en cuenta y en este caso, construiremos un cluster de Kubernetes en GCP usando terraform.&lt;/p&gt;
&lt;h3 id=&#34;conectandonos-a-google-cloud-platform&#34;&gt;Conectandonos a Google Cloud platform:&lt;/h3&gt;
&lt;p&gt;Para conectarnos a GCP solo necesitamos determinar:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Credentials&lt;/strong&gt; : En este caso tenemos que generar un account service y usar el archivo json que se genera con los permisos necesarios&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project&lt;/strong&gt;  : Determinamos el proyecto en GCP en el cual vamos a trabajar&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;region&lt;/strong&gt; : Determinamos la región por el cual vamos a trabajar.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Despues de determinar los valores mencionados anteriormente, los seteamos en el siguiente archivo.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Utilizando Traefik como Dynamic Reverse Proxy en Docker Swarm sobre  AWS</title>
      <link>/posts/utilizando-traefik-como-dynamic-reverse-proxy-en-docker-swarm-sobre-aws/</link>
      <pubDate>Fri, 22 Dec 2017 01:20:18 +0000</pubDate>
      
      <guid>/posts/utilizando-traefik-como-dynamic-reverse-proxy-en-docker-swarm-sobre-aws/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;/images/traefik.png&#34; alt=&#34;image1&#34;&gt;&lt;/p&gt;
&lt;p&gt;Traefik es una herramienta muy potente gracias a que soporta varios providers como backend, en este caso usaremos traefik para que nos sirva como &lt;strong&gt;Dynamic Reverse Proxy&lt;/strong&gt; sobre un cluster de &lt;strong&gt;Docker Swarm&lt;/strong&gt; en &lt;strong&gt;Amazon Web Services&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;componentes&#34;&gt;Componentes:&lt;/h3&gt;
&lt;h4 id=&#34;3-instancias-1-manager-y-2-worker&#34;&gt;3 Instancias (1 Manager  y 2 worker):&lt;/h4&gt;
&lt;p&gt;**Manager: **Esta instancia sera la que controlara todo el cluster, en ella desplegaremos traefik y los servicios que no son worker, esta instancia estará sobre una subnet , la cual llamaremos **“subnet frontend” **y tendrá su respectivo Secure Group&lt;/p&gt;
&lt;p&gt;**Worker: **las instancias llamadas workers son dichas instancias donde correran nuestros servicios desplegados en AWS, sin tener en cuenta los servicios de “management” que podemos desplegar en la subnet de frontend, aquí desplegaremos los servicios que necesitemos como un web server, un micro servicio, etc, estas dos instancias estarán sobre otra subnet, la cual la llamaremos &lt;strong&gt;“subnet backend”&lt;/strong&gt; y tendrá su respectivo Secure Group&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Traefik: Load Balancer y Reverse Proxy para Docker</title>
      <link>/posts/traefik-load-balancer-y-reverse-proxy-para-docker/</link>
      <pubDate>Wed, 25 Oct 2017 22:25:26 +0000</pubDate>
      
      <guid>/posts/traefik-load-balancer-y-reverse-proxy-para-docker/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;/images/traefik.png&#34; alt=&#34;image1&#34;&gt;&lt;/p&gt;
&lt;p&gt;Cuando trabajamos con docker en ambientes productivos, la mayoría de casos usamos tecnologías para orquestar y poder ofrecer alta disponibilidad sobre nuestros micro servicios, debido a esto, nosotros corremos multiples aplicaciones sobre un mismo host que haga parte de nuestro stack de orquestación. Para que estas aplicaciones puedan ser consumidas sin necesidad de exponer un puerto, necesitamos un reverse proxy para poder consumir estos servicios desde un único puerto.&lt;/p&gt;
&lt;p&gt;**Traefik **es un reverse proxy  y load balancer compatible con docker escrito en Go, creado especialmente para micro servicios, Traefik soporta diferentes Backends como: &lt;strong&gt;(Docker, docker Swarm, Kubernetes, Rancher, Amazon ECS y muchos mas )&lt;/strong&gt; su configuración es bastante sencilla y cuenta con un Dashboard donde podemos visualizar nuestros Micro servicios.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Howto: Instalando Rocket.Chat en Docker</title>
      <link>/posts/howto-instalando-rocket.chat-en-docker/</link>
      <pubDate>Tue, 07 Mar 2017 06:54:30 +0000</pubDate>
      
      <guid>/posts/howto-instalando-rocket.chat-en-docker/</guid>
      <description>&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Rocket.chat para mi es una de las mejores plataformas de chat &lt;strong&gt;OpenSource&lt;/strong&gt; que existen, es muy flexible a la hora de adaptarlo y lo mejor, tiene cliente para toda las plataformas.&lt;/p&gt;
&lt;p&gt;En este caso, realizaremos la instalación de Rocket.chat en &lt;strong&gt;docker&lt;/strong&gt;, por el cual no importara la distribución linux que utilicemos, pero en este caso utilizare Centos 7 como host de mis contenedores para hacer el despliegue.&lt;/p&gt;
&lt;h2 id=&#34;instalación&#34;&gt;Instalación:&lt;/h2&gt;
&lt;p&gt;Vamos a usar varios contenedores y para lograr la comunicación entre ellos, se usara &lt;strong&gt;Docker Compose&lt;/strong&gt;, el cual nos permite hacer despliegues de servicios el cual involucra varios contenedores.&lt;/p&gt;
&lt;h3 id=&#34;docker&#34;&gt;Docker:&lt;/h3&gt;
&lt;p&gt;Instalamos docker usando el script que se encuentra en su pagina oficial.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;wget -qO- https://get.docker.com/ | sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Al finalizar el proceso usamos systemctl para subir el servicio y dejarlo habilitado para que inicie cuando se inicie el servidor.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;systemctl start enable

systemcl enable docker
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>